-- MySQL dump 10.13  Distrib 8.0.18, for Win64 (x86_64)
--
-- Host: localhost    Database: plagcheck
-- ------------------------------------------------------
-- Server version	8.0.18

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `problems`
--

DROP TABLE IF EXISTS `problems`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `problems` (
  `id` int(11) NOT NULL,
  `name` varchar(45) NOT NULL,
  `timeLimit` float NOT NULL,
  `memoryLimit` float NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problems`
--

LOCK TABLES `problems` WRITE;
/*!40000 ALTER TABLE `problems` DISABLE KEYS */;
INSERT INTO `problems` VALUES (1,'Got Any Grapes?',1,256),(2,'Yet Another Array Partitioning Task',2,256),(3,'Flood Fill',2,256),(4,'Arithmetic Progression',2,256),(5,'Please, another Queries on Array?',5.5,256),(6,'[Basic1] Giải phương trình',1,256),(7,'[Basic1] How old are you?',1,256);
/*!40000 ALTER TABLE `problems` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `solutions`
--

DROP TABLE IF EXISTS `solutions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `solutions` (
  `id` int(11) NOT NULL,
  `problem_id` int(11) NOT NULL,
  `lang` varchar(45) NOT NULL,
  `content` blob NOT NULL,
  PRIMARY KEY (`id`),
  KEY `problem_id_idx` (`problem_id`),
  CONSTRAINT `fk` FOREIGN KEY (`problem_id`) REFERENCES `problems` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `solutions`
--

LOCK TABLES `solutions` WRITE;
/*!40000 ALTER TABLE `solutions` DISABLE KEYS */;
INSERT INTO `solutions` VALUES (1,1,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nint x, y, z, a, b, c;\n\nvoid Input() {\n	cin >> x >> y >> z;\n	cin >> a >> b >> c;\n}\n\nvoid Solve() {\n	if (x > a) {cout << \"NO\\n\"; return;}\n	if (x + y > a + b) {cout << \"NO\\n\"; return;}\n	if (x + y + z > a + b + c) {cout << \"NO\\n\"; return;}\n	cout << \"YES\\n\";\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0);\n	cin.tie(NULL); Input(); Solve();\n	return 0;\n}'),(2,2,'C++',_binary '#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(NULL);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<pii> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n\n    sort(a.begin(), a.end(), greater<pii>());\n\n    vector<int> ind(m*k);\n    ll sumBeauty = 0;\n    for(int i = 0; i < m*k; ++i) {\n        sumBeauty += a[i].first;\n        ind[i] = a[i].second;\n    }\n\n    sort(ind.begin(), ind.end());\n\n    vector<int> division(k-1);\n    for(int i = 0; i < k-1; ++i)\n        division[i] = ind[(i+1)*m - 1];\n\n    cout << sumBeauty << endl;\n    for(int p: division)\n        cout << p + 1 << \" \";\n\n    return 0;\n}'),(3,3,'C++',_binary '// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nint dp[5000][5000][2];\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n\n    vector<int> a(n);\n    input_seq(ALL(a));\n\n    for (int i = 0; i != n; ++i)\n        for (int j = 0; j != n; ++j)\n            dp[i][j][0] = dp[i][j][1] = (i == j ? 0 : TYPEMAX(int) / 2);\n    \n\n    for (int r = 0; r != n; ++r)\n        for (int l = r; l >= 0; --l)\n            for (int it = 0; it != 2; ++it) {\n                int c = (it == 0 ? a[l] : a[r]);\n                \n                if (l)\n                    dp[l - 1][r][0] = min(dp[l - 1][r][0], dp[l][r][it] + int(c != a[l - 1]));\n\n                if (r + 1 != n)\n                    dp[l][r + 1][1] = min(dp[l][r + 1][1], dp[l][r][it] + int(c != a[r + 1]));\n            }\n\n    cout << min(dp[0][n - 1][0], dp[0][n - 1][1]) << \"\\n\";\n    \n    return 0;\n}'),(4,3,'C++',_binary '#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 5008;\n\nint n;\nint dp[maxN][maxN];\nvector<int> a(1), b;\nvector<int> ans;\n\nvoid input() {\n	cin >> n;\n	for (int i = 0; i < n; i++) {\n		int x; cin >> x;\n		if (x != a.back()) a.push_back(x);\n	}\n	n = a.size() - 1;\n\n	b = a;\n	reverse(b.begin() + 1, b.end());\n}\n\nvoid solve() {\n	for (int i = 1; i <= n; i++) {\n		for (int j = 1; j <= n; j++) {\n			if (a[i] == b[j]) {dp[i][j] = dp[i-1][j-1] + 1;}\n			else {dp[i][j] = max(dp[i-1][j], dp[i][j-1]);}\n		}\n	}\n}\n\nvoid output() {\n	cout << n - (dp[n][n] + 1)/2 << \'\\n\';\n}\n\nint main() {\n	\n	input();\n	solve();\n	output();\n	\n	return 0;\n}'),(5,4,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\n\nint n, Max = -1000000000, d = 0;\nint queryRemaining = 60; vector<int> id;\n\nvoid findMax() {\n	int top = -1000000000, bot = +1000000000;\n	while (top <= bot) {\n		int hasHigher;\n		int mid = (top + bot) / 2;\n		cout << \"> \" << mid << endl;\n		fflush(stdout); cin >> hasHigher;\n		queryRemaining--;\n		if (hasHigher) top = mid + 1;\n		else {bot = mid - 1; Max = mid;}\n	}\n}\n\nvoid findD() {\n	vector<int> List; int RandomRange = n;\n	while (queryRemaining > 0 && RandomRange > 0) {\n		int demandedIndex = rng32() % RandomRange;\n		cout << \"? \" << id[demandedIndex] << endl; fflush(stdout);\n		int z; cin >> z; List.push_back(z);\n		RandomRange--; queryRemaining--;\n		swap(id[demandedIndex], id[RandomRange]);\n	}\n	sort(List.begin(), List.end());\n	if (List.back() != Max) List.push_back(Max);\n	for (int i=1; i<List.size(); i++) {\n		d = __gcd(d, List[i] - List[i-1]);\n	}\n}\n\nvoid Input() {\n	cin >> n; id.resize(n);\n	for (int i=0; i<n; i++) id[i] = i+1;\n}\n\nvoid Solve() {\n	findMax(); findD();\n	int Min = Max - d * (n - 1);\n	cout << \"! \" << Min << \" \" << d;\n	cout << endl; fflush(stdout);\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0);\n	Input(); Solve(); return 0;\n}'),(6,5,'C++',_binary '// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 1000 * 1000 * 1000 + 7;\n\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a) * b) % mod;\n}\n\nint fpow(int a, int n, int r = 1) {\n    while (n) {\n        if (n % 2)\n            r = mult(r, a);\n\n        n /= 2;\n        a = mult(a, a);\n    }\n\n    return r;\n}\n\n\nconst int max_n = 4.1e5;\nint tree[4 * max_n];\nint modif[4 * max_n];\nint64_t pmask[4 * max_n], pushmask[4 * max_n];\n\nvector<int> primes, revprimes;\n\nvoid build(int v, int l, int r, vector<int>& a) {\n    modif[v] = 1;\n    \n    if (l == r - 1) {\n        tree[v] = a[l];\n\n        for (int i = 0; i != SZ(primes); ++i)\n            if (a[l] % primes[i] == 0)\n                pmask[v] |= (int64_t(1) << int64_t(i));\n    } else {\n        int m = l + (r - l) / 2;\n        build(2 * v + 1, l, m, a);\n        build(2 * v + 2, m, r, a);\n\n        tree[v] = mult(tree[2 * v + 1], tree[2 * v + 2]);\n        pmask[v] = pmask[2 * v + 1] | pmask[2 * v + 2];\n    }\n}\n\nvoid push(int v, int vl, int vr) {\n    if (modif[v] != 1)\n        tree[v] = fpow(modif[v], vr - vl, tree[v]);\n\n    pmask[v] |= pushmask[v];\n    \n    if (vl != vr - 1) {\n        modif[2 * v + 1] = mult(modif[2 * v + 1], modif[v]);\n        modif[2 * v + 2] = mult(modif[2 * v + 2], modif[v]);\n\n        pushmask[2 * v + 1] |= pushmask[v];\n        pushmask[2 * v + 2] |= pushmask[v];\n    }\n\n    modif[v] = 1;\n    pushmask[v] = 0;\n}\n\npair<int, int64_t> get(int v, int vl, int vr, int l, int r) {\n    if (vr <= l or r <= vl)\n        return make_pair<int, int64_t>(1, 0);\n    \n    push(v, vl, vr);\n\n    if (l <= vl and vr <= r)\n        return make_pair(tree[v], pmask[v]);\n\n    int vm = vl + (vr - vl) / 2;\n    \n    auto r1 = get(2 * v + 1, vl, vm, l, r);\n    auto r2 = get(2 * v + 2, vm, vr, l, r);\n\n    return make_pair(mult(r1.first, r2.first), r1.second | r2.second);\n}\n\nvoid multiply(int v, int vl, int vr, int l, int r, int x, int64_t mask) {\n    if (vr <= l or r <= vl)\n        return;\n\n    push(v, vl, vr);\n    \n    if (l <= vl and vr <= r) {\n        pushmask[v] = mask;\n        modif[v] = x;\n        return;\n    }\n\n    int vm = vl + (vr - vl) / 2;\n    \n    multiply(2 * v + 1, vl, vm, l, r, x, mask);\n    multiply(2 * v + 2, vm, vr, l, r, x, mask);\n\n    pmask[v] = pmask[2 * v + 1] | pmask[2 * v + 2] | pushmask[2 * v + 1] | pushmask[2 * v + 2];\n    tree[v] = fpow(x, min(vr, r) - max(l, vl), tree[v]);\n}\n\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    for (int i = 2; i <= 300; ++i) {\n        bool ok = true;\n        for (int j = 2; j * j <= i and ok; ++j)\n            if (i % j == 0)\n                ok = false;\n\n        if (ok) {\n            primes.push_back(i);\n            revprimes.push_back(fpow(i, mod - 2));\n        }\n    }\n\n    int n = input<int>();\n    int q = input<int>();\n\n    vector<int> a(n);\n    input_seq(ALL(a));\n\n    build(0, 0, n, a);\n\n    for (int it = 0; it != q; ++it) {\n        if (input<string>() == \"TOTIENT\") {\n            int l = input<int>() - 1;\n            int r = input<int>() - 1;\n            \n            pair<int, uint64_t> prod = get(0, 0, n, l, r + 1);\n            for (int i = 0; i != SZ(primes); ++i)\n                if (prod.second & (int64_t(1) << int64_t(i)))\n                    prod.first = mult(mult(prod.first, primes[i] - 1), revprimes[i]);\n\n            cout << prod.first << \"\\n\";\n        } else {\n            int l = input<int>() - 1;\n            int r = input<int>() - 1;\n            int x = input<int>();\n\n            int64_t msk = 0;\n            for (int i = 0; i != SZ(primes); ++i)\n                if (x % primes[i] == 0)\n                    msk |= (int64_t(1) << int64_t(i));\n\n            multiply(0, 0, n, l, r + 1, x, msk);\n        }\n    }\n    \n    return 0;\n}'),(7,5,'C++',_binary '#define _CRT_SECURE_NO_WARNINGS\n#pragma GCC optimize(\"unroll-loops\")\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <ctime>\n#include <unordered_set>\n#include <string>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <set>\n#include <cassert>\n#include <functional>\n#include <iomanip>\n#include <queue>\n#include <numeric>\n#include <bitset>\n#include <iterator>\n\nusing namespace std;\n\nconst int N = 100001;\n\nmt19937 gen(time(NULL));\n#define forn(i, n) for (int i = 0; i < n; i++)\n#define ford(i, n) for (int i = n - 1; i >= 0; i--)\n#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#define all(a) (a).begin(), (a).end()\n#define pii pair<int, int>\n#define mp make_pair\n#define endl \'\\n\'\n#define vi vector<int>\n\ntypedef long long ll;\n\ntemplate<typename T = int>\ninline T read() {\n	T val = 0, sign = 1; char ch;\n	for (ch = getchar(); ch < \'0\' || ch > \'9\'; ch = getchar())\n		if (ch == \'-\') sign = -1;\n	for (; ch >= \'0\' && ch <= \'9\'; ch = getchar())\n		val = val * 10 + ch - \'0\';\n	return sign * val;\n}\n\nconst int mod = 1e9 + 7;\nconst int phi = 1e9 + 6;\n\nconst int M = 301, B = 500;\nint P = 0;\n\ninline int mul(int a, int b) {\n	return (a * 1LL * b) % mod;\n}\n\nint mpow(int u, int p) {\n	if (!p) return 1;\n	return mul(mpow(mul(u, u), p / 2), (p & 1) ? u : 1);\n}\n\nvector<int> primes;\nvector<int> pi;\n\nint pw[M];\nint lg[N];\n\nbool pr(int x) {\n	if (x <= 1) return false;\n	for (int i = 2; i * i <= x; i++)\n		if (x % i == 0)\n			return false;\n	return true;\n}\n\nvoid precalc() {\n	forn(i, M)\n		if (pr(i)) {\n			primes.push_back(i);\n			P++;\n		}\n	pi.resize(P);\n	forn(i, M) {\n		int x = 1;\n		forn(j, B) {\n			x = mul(x, i);\n		}\n		pw[i] = x;\n	}\n\n	forn(i, P)\n		pi[i] = mpow(primes[i], phi - 1);\n}\n\nstruct product_tree {\n	vector<int> arr, block_product, block_update, single_update;\n	int n;\n\n	product_tree(vector<int>& a) : n(a.size()) {\n		arr = a;\n		while (n % B) {\n			n++, arr.push_back(1);\n		}\n		block_product.resize(n / B, 1);\n		block_update.resize(n / B, -1);\n		single_update.resize(n / B, -1);\n\n		for (int i = 0; i < n; i += B) {\n			int x = 1;\n			int pos = i / B;\n			forn(j, B)\n				x = mul(x, arr[i + j]);\n			block_product[pos] = x;\n		}\n	}\n\n	inline void add(int& u, int x, int mode) {\n		if (mode) {\n			if (u == -1)\n				u = x;\n			else\n				u = mul(u, x);\n		}\n		else {\n			if (u == -1)\n				u = pw[x];\n			else\n				u = mul(u, pw[x]);\n		}\n	}\n\n	void update(int pos, int x) {\n		add(block_update[pos], x, 0);\n		add(single_update[pos], x, 1);\n	}\n\n	void reconstruct(int pos) {\n		int e = single_update[pos];\n		if (e == -1) return;\n		int x = 1;\n\n		int l = pos * B, r = l + B;\n		for (int i = l; i < r; i++) {\n			arr[i] = mul(arr[i], e);\n			x = mul(x, arr[i]);\n		}\n\n		single_update[pos] = block_update[pos] = -1;\n		block_product[pos] = x;\n	}\n\n	void apply(int l, int r, int x) {\n		int L = l / B, R = r / B;\n		if (L == R) {\n			reconstruct(L);\n			for (int i = l; i <= r; i++) {\n				arr[i] = mul(arr[i], x);\n				block_product[L] = mul(block_product[L], x);\n			}\n			return;\n		}\n		reconstruct(L);\n		for (int i = l; i < (L + 1) * B; i++) {\n			arr[i] = mul(arr[i], x);\n			block_product[L] = mul(block_product[L], x);\n		}\n		reconstruct(R);\n		for (int i = R * B; i <= r; i++) {\n			arr[i] = mul(arr[i], x);\n			block_product[R] = mul(block_product[R], x);\n		}\n		for (int j = L + 1; j < R; j++)\n			update(j, x);\n	}\n\n	int get(int l, int r) {\n		int L = l / B, R = r / B;\n		int ans = 1;\n		if (L == R) {\n			reconstruct(L);\n			for (int i = l; i <= r; i++) {\n				ans = mul(ans, arr[i]);\n			}\n			return ans;\n		}\n		reconstruct(L);\n		for (int i = l; i < (L + 1) * B; i++) {\n			ans = mul(ans, arr[i]);\n		}\n		reconstruct(R);\n		for (int i = R * B; i <= r; i++) {\n			ans = mul(ans, arr[i]);\n		}\n		for (int j = L + 1; j < R; j++) {\n			ans = mul(ans, block_product[j]);\n			if (block_update[j] != -1)\n				ans = mul(ans, block_update[j]);\n		}\n		return ans;\n	}\n};\n\nstruct prime_tree {\n	vector<ll> t, d;\n	int n;\n\n	prime_tree(vector<ll>& a) : n(a.size()) {\n		t.resize(4 * n);\n		d.resize(4 * n, -1);\n		build(1, 0, n, a);\n	}\n\n	ll build(int u, int l, int r, vector<ll>& a) {\n		if (l == r - 1) {\n			return t[u] = a[l];\n		}\n		int m = (l + r) / 2;\n		return t[u] = build(u << 1, l, m, a) | build(u << 1 | 1, m, r, a);\n	}\n\n	inline void add(ll& u, ll x) {\n		if (u == -1)\n			u = x;\n		else\n			u |= x;\n	}\n\n	void push(int u, int l, int r) {\n		if (d[u] == -1) return;\n		t[u] |= d[u];\n		if (r - l > 1) {\n			add(d[u << 1], d[u]);\n			add(d[u << 1 | 1], d[u]);\n		}\n		d[u] = -1;\n	}\n\n	void update(int u, int l, int r, int L, int R, ll x) {\n		push(u, l, r);\n		if (L >= R || l > L || r < R) return;\n		if (l == L && r == R) {\n			add(d[u], x);\n			push(u, l, r);\n			return;\n		}\n		int m = (l + r) / 2;\n		update(u << 1, l, m, L, min(m, R), x);\n		update(u << 1 | 1, m, r, max(L, m), R, x);\n\n		t[u] = t[u << 1] | t[u << 1 | 1];\n	}\n\n	ll get(int u, int l, int r, int L, int R) {\n		push(u, l, r);\n		if (L >= R || l > L || r < R) return 0;\n		if (l == L && r == R) {\n			return t[u];\n		}\n		int m = (l + r) / 2;\n		return get(u << 1, l, m, L, min(m, R)) | get(u << 1 | 1, m, r, max(L, m), R);\n	}\n\n	ll get(int l, int r) {\n		return get(1, 0, n, l, r + 1);\n	}\n	void apply(int l, int r, ll x) {\n		update(1, 0, n, l, r + 1, x);\n	}\n};\n\nll transform(int x) {\n	ll mask = 0;\n	forn(i, P)\n		if (x % primes[i] == 0) {\n			mask |= (1LL << i);\n		}\n	return mask;\n}\n\nvoid solve() {\n	int n, q; cin >> n >> q;\n\n	vi a(n);\n	vector<ll> _a;\n\n	for (auto& v : a) {\n		cin >> v;\n		_a.push_back(transform(v));\n	}\n\n	auto Ptree = product_tree(a);\n	auto Mtree = prime_tree(_a);\n\n	int l, r, x;\n	forn(i, q) {\n		string s; cin >> s;\n		if (s == \"MULTIPLY\") {\n			cin >> l >> r >> x;\n			l--, r--;\n			Ptree.apply(l, r, x);\n			Mtree.apply(l, r, transform(x));\n		}\n		else {\n			cin >> l >> r;\n			l--, r--;\n\n			int product = Ptree.get(l, r);\n			ll mask = Mtree.get(l, r);\n\n			forn(j, 63)\n				if (mask >> j & 1) {\n					product = mul(product, primes[j] - 1);\n					product = mul(product, pi[j]);\n				}\n\n			cout << product << endl;\n		}\n	}\n}\n\nsigned main() {\n	int t = 1;\n\n	ios_base::sync_with_stdio(0);\n	cin.tie(0);\n\n	precalc();\n\n	while (t--) {\n		clock_t z = clock();\n		solve();\n		debug(\"Total Time: %.3f\\n\", (double)(clock() - z) / CLOCKS_PER_SEC);\n	}\n}'),(8,5,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nconst int Mod = 1000000007;\n\nint prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137\n,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293}; // (size = 62)\n\nint modPow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 == 0) {a = (1LL * a * a) % Mod; b /= 2;}\n        else {res = (1LL * res * a) % Mod; b -= 1;}\n    }\n    return res;\n}\n\nstruct ProTree {\n	vector<int> Tree, Lazy;\n	ProTree() {}\n	ProTree(int n) {Tree.resize(n*4, 1); Lazy.resize(n*4, 1);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 1) return;\n		Tree[node] = (1LL * Tree[node] * modPow(Lazy[node], (en - st + 1))) % Mod;\n		if (st != en) {\n			Lazy[node*2+1] = (1LL * Lazy[node*2+1] * Lazy[node]) % Mod;\n			Lazy[node*2+2] = (1LL * Lazy[node*2+2] * Lazy[node]) % Mod;\n		}\n		Lazy[node] = 1;\n	}\n	\n	void Multiply(int node, int st, int en, int L, int R, int val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] = (1LL * Lazy[node] * val) % Mod;\n			Propagate(node, st, en); return;\n		}\n		Multiply(node*2+1, st, (st+en)/2+0, L, R, val);\n		Multiply(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (1LL * Tree[node*2+1] * Tree[node*2+2]) % Mod;\n	}\n	\n	int Product(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 1;\n		if (L <= st && en <= R) return Tree[node];\n		int p1 = Product(node*2+1, st, (st+en)/2+0, L, R);\n		int p2 = Product(node*2+2, (st+en)/2+1, en, L, R);\n		return ((1LL * p1 * p2) % Mod);\n	}\n};\n\nstruct OrTree {\n	vector<long long> Tree, Lazy;\n	OrTree() {}\n	OrTree(int n) {Tree.resize(n*4); Lazy.resize(n*4);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 0) return;\n		Tree[node] |= Lazy[node];\n		if (st != en) {\n			Lazy[node*2+1] |= Lazy[node];\n			Lazy[node*2+2] |= Lazy[node];\n		}\n		Lazy[node] = 0;\n	}\n	\n	void Update(int node, int st, int en, int L, int R, long long val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] |= val;\n			Propagate(node, st, en); return;\n		}\n		Update(node*2+1, st, (st+en)/2+0, L, R, val);\n		Update(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (Tree[node*2+1] | Tree[node*2+2]);\n	}\n	\n	long long Or(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 0;\n		if (L <= st && en <= R) return Tree[node];\n		long long p1 = Or(node*2+1, st, (st+en)/2+0, L, R);\n		long long p2 = Or(node*2+2, (st+en)/2+1, en, L, R);\n		return (p1 | p2);\n	}\n};\n\nint N, Q, l, r, x; string cmd;\nvector<int> invPrime(62);\nvector<int> A; ProTree PrTree; OrTree OSTree;\nvector<long long> Mask(301, 0);\n\nvoid PreprocessMask() {\n	for (int z=1; z<=300; z++) {\n		for (int i=0; i<62; i++) {\n			if (z % prime[i] != 0) continue;\n			Mask[z] |= (1LL << i);\n		}\n	}\n}\n\nvoid Input() {\n    for (int i=0; i<62; i++) invPrime[i] = modPow(prime[i], Mod-2); PreprocessMask();\n	cin >> N >> Q; A.resize(N); PrTree = ProTree(N); OSTree = OrTree(N);\n	for (int i=0; i<N; i++) {\n		cin >> A[i];\n		PrTree.Multiply(0, 0, N-1, i, i, A[i]);\n		OSTree.Update(0, 0, N-1, i, i, Mask[A[i]]);\n	}\n}\n\nvoid Solve() {\n	while (Q--) {\n		cin >> cmd >> l >> r; l--; r--;\n		if (cmd == \"MULTIPLY\") {\n			cin >> x;\n			PrTree.Multiply(0, 0, N-1, l, r, x);\n    		OSTree.Update(0, 0, N-1, l, r, Mask[x]);\n		}\n		else if (cmd == \"TOTIENT\") {\n			int res = PrTree.Product(0, 0, N-1, l, r);\n			long long SegMask = OSTree.Or(0, 0, N-1, l, r);\n			for (int i=0; i<62; i++) {\n			    if ((SegMask & (1LL << i)) == 0) continue;\n			    res = (1LL * res * (prime[i] - 1)) % Mod;\n			    res = (1LL * res * invPrime[i]) % Mod;\n			}\n			cout << res << endl;\n		}\n	}\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(9,5,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nconst int Mod = 1000000007;\n\nint prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137\n,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293}; // (size = 62)\n\nint modPow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 == 0) {a = (1LL * a * a) % Mod; b /= 2;}\n        else {res = (1LL * res * a) % Mod; b -= 1;}\n    }\n    return res;\n}\n\nstruct ProTree {\n	vector<int> Tree, Lazy;\n	ProTree() {}\n	ProTree(int n) {Tree.resize(n*4, 1); Lazy.resize(n*4, 1);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 1) return;\n		Tree[node] = (1LL * Tree[node] * modPow(Lazy[node], (en - st + 1))) % Mod;\n		if (st != en) {\n			Lazy[node*2+1] = (1LL * Lazy[node*2+1] * Lazy[node]) % Mod;\n			Lazy[node*2+2] = (1LL * Lazy[node*2+2] * Lazy[node]) % Mod;\n		}\n		Lazy[node] = 1;\n	}\n	\n	void Multiply(int node, int st, int en, int L, int R, int val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] = (1LL * Lazy[node] * val) % Mod;\n			Propagate(node, st, en); return;\n		}\n		Multiply(node*2+1, st, (st+en)/2+0, L, R, val);\n		Multiply(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (1LL * Tree[node*2+1] * Tree[node*2+2]) % Mod;\n	}\n	\n	int Product(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 1;\n		if (L <= st && en <= R) return Tree[node];\n		int p1 = Product(node*2+1, st, (st+en)/2+0, L, R);\n		int p2 = Product(node*2+2, (st+en)/2+1, en, L, R);\n		return ((1LL * p1 * p2) % Mod);\n	}\n};\n\nstruct OrTree {\n	vector<long long> Tree, Lazy;\n	OrTree() {}\n	OrTree(int n) {Tree.resize(n*4); Lazy.resize(n*4);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 0) return;\n		Tree[node] |= Lazy[node];\n		if (st != en) {\n			Lazy[node*2+1] |= Lazy[node];\n			Lazy[node*2+2] |= Lazy[node];\n		}\n		Lazy[node] = 0;\n	}\n	\n	void Update(int node, int st, int en, int L, int R, long long val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] |= val;\n			Propagate(node, st, en); return;\n		}\n		Update(node*2+1, st, (st+en)/2+0, L, R, val);\n		Update(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (Tree[node*2+1] | Tree[node*2+2]);\n	}\n	\n	long long Or(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 0;\n		if (L <= st && en <= R) return Tree[node];\n		long long p1 = Or(node*2+1, st, (st+en)/2+0, L, R);\n		long long p2 = Or(node*2+2, (st+en)/2+1, en, L, R);\n		return (p1 | p2);\n	}\n};\n\nint N, Q, l, r, x; string cmd;\nvector<int> invPrime(62);\nvector<int> A; ProTree PrTree; OrTree OSTree;\nvector<long long> Mask(301, 0);\n\nvoid PreprocessMask() {\n	for (int z=1; z<=300; z++) {\n		for (int i=0; i<62; i++) {\n			if (z % prime[i] != 0) continue;\n			Mask[z] |= (1LL << i);\n		}\n	}\n}\n\nvoid Input() {\n    for (int i=0; i<62; i++) invPrime[i] = modPow(prime[i], Mod-2); PreprocessMask();\n	cin >> N >> Q; A.resize(N); PrTree = ProTree(N); OSTree = OrTree(N);\n	for (int i=0; i<N; i++) {\n		cin >> A[i];\n		PrTree.Multiply(0, 0, N-1, i, i, A[i]);\n		OSTree.Update(0, 0, N-1, i, i, Mask[A[i]]);\n	}\n}\n\nvoid Solve() {\n	while (Q--) {\n		cin >> cmd >> l >> r; l--; r--;\n		if (cmd == \"MULTIPLY\") {\n			cin >> x;\n			PrTree.Multiply(0, 0, N-1, l, r, x);\n			OSTree.Update(0, 0, N-1, l, r, Mask[x]);\n		}\n		else if (cmd == \"TOTIENT\") {\n			int res = PrTree.Product(0, 0, N-1, l, r);\n			long long SegMask = OSTree.Or(0, 0, N-1, l, r);\n			for (int i=0; i<62; i++) {\n			    if ((SegMask & (1LL << i)) == 0) continue;\n			    res = (1LL * res * (prime[i] - 1)) % Mod;\n			    res = (1LL * res * invPrime[i]) % Mod;\n			}\n			cout << res << endl;\n		}\n	}\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(10,3,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nint n; vector<int> c;\nint dp[5000][5000][2];\n// Third dimension: 0 for left col, 1 for right col\nint Inf = 1000000000;\n\nvoid Input() {\n	cin >> n; c.resize(n);\n    for (int i=0; i<n; i++) cin >> c[i];\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<n; j++) {\n            for (int dir=0; dir<2; dir++) {\n                dp[i][j][dir] = Inf;\n            }\n        }\n    }\n}\n\nvoid Solve() {\n    for (int i=0; i<n; i++) {\n        dp[i][i][0] = dp[i][i][1] = 0;\n    }\n    for (int Len=1; Len<n; Len++) {\n        for (int i=0; i<=n-Len; i++) {\n            int j = i + Len - 1;\n            for (int dir=0; dir<2; dir++) {\n                int col = (dir == 0) ? c[i] : c[j];\n                if (i > 0) {\n                    dp[i-1][j][0] = min(dp[i-1][j][0], dp[i][j][dir] + (col != c[i-1]));\n                }\n                if (j+1 < n) {\n                    dp[i][j+1][1] = min(dp[i][j+1][1], dp[i][j][dir] + (col != c[j+1]));\n                }\n            }\n        }\n    }\n    cout << min(dp[0][n-1][0], dp[0][n-1][1]) << endl;\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(11,2,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nint n, m, k; vector<pair<int, int>> a;\n\nvoid Input() {\n	cin >> n >> m >> k; a.resize(n);\n    for (int i=0; i<n; i++) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n}\n\nvoid Solve() {\n    sort(a.rbegin(), a.rend());\n    vector<bool> contained(n, false);\n    long long sum = 0; vector<int> PartitionList;\n    for (int i=0; i<m*k; i++) {\n        int id = a[i].second;\n        contained[id] = true;\n        sum += a[i].first;\n    }\n    int curseg = 0;\n    for (int i=0; i<n; i++) {\n        curseg += contained[i];\n        if (curseg == m) {curseg = 0; PartitionList.push_back(i+1);}\n        if (PartitionList.size() == k-1) break;\n    }\n    cout << sum << endl;\n    for (auto x: PartitionList) cout << x << \" \"; cout << endl;\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(12,5,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nconst int Mod = 1000000007;\n\nint prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137\n,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293}; // (size = 62)\n\nint modPow(int a, int b) {\n    if (b == 0) return 1;\n    int tmp = modPow(a, b/2);\n    if (b % 2 == 0) return ((1LL * tmp * tmp) % Mod);\n    return ((((1LL * tmp * tmp) % Mod) * a) % Mod);\n}\n\nstruct ProTree {\n	vector<int> Tree, Lazy;\n	ProTree() {}\n	ProTree(int n) {Tree.resize(n*4, 1); Lazy.resize(n*4, 1);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 1) return;\n		Tree[node] = (1LL * Tree[node] * modPow(Lazy[node], (en - st + 1))) % Mod;\n		if (st != en) {\n			Lazy[node*2+1] = (1LL * Lazy[node*2+1] * Lazy[node]) % Mod;\n			Lazy[node*2+2] = (1LL * Lazy[node*2+2] * Lazy[node]) % Mod;\n		}\n		Lazy[node] = 1;\n	}\n	\n	void Multiply(int node, int st, int en, int L, int R, int val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] = (1LL * Lazy[node] * val) % Mod;\n			Propagate(node, st, en); return;\n		}\n		Multiply(node*2+1, st, (st+en)/2+0, L, R, val);\n		Multiply(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (1LL * Tree[node*2+1] * Tree[node*2+2]) % Mod;\n	}\n	\n	int Product(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 1;\n		if (L <= st && en <= R) return Tree[node];\n		int p1 = Product(node*2+1, st, (st+en)/2+0, L, R);\n		int p2 = Product(node*2+2, (st+en)/2+1, en, L, R);\n		return ((1LL * p1 * p2) % Mod);\n	}\n};\n\nstruct OrTree {\n	vector<long long> Tree, Lazy;\n	OrTree() {}\n	OrTree(int n) {Tree.resize(n*4); Lazy.resize(n*4);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 0) return;\n		Tree[node] |= Lazy[node];\n		if (st != en) {\n			Lazy[node*2+1] |= Lazy[node];\n			Lazy[node*2+2] |= Lazy[node];\n		}\n		Lazy[node] = 0;\n	}\n	\n	void Update(int node, int st, int en, int L, int R, long long val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] |= val;\n			Propagate(node, st, en); return;\n		}\n		Update(node*2+1, st, (st+en)/2+0, L, R, val);\n		Update(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (Tree[node*2+1] | Tree[node*2+2]);\n	}\n	\n	long long Or(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 0;\n		if (L <= st && en <= R) return Tree[node];\n		long long p1 = Or(node*2+1, st, (st+en)/2+0, L, R);\n		long long p2 = Or(node*2+2, (st+en)/2+1, en, L, R);\n		return (p1 | p2);\n	}\n};\n\nint N, Q, l, r, x; string cmd;\nvector<int> invPrime(62);\nvector<int> A; ProTree PrTree; OrTree OSTree;\nvector<long long> Mask(301, 0);\n\nvoid PreprocessMask() {\n	for (int z=1; z<=300; z++) {\n		for (int i=0; i<62; i++) {\n			if (z % prime[i] != 0) continue;\n			Mask[z] |= (1LL << i);\n		}\n	}\n}\n\nvoid Input() {\n    for (int i=0; i<62; i++) invPrime[i] = modPow(prime[i], Mod-2); PreprocessMask();\n	cin >> N >> Q; A.resize(N); PrTree = ProTree(N); OSTree = OrTree(N);\n	for (int i=0; i<N; i++) {\n		cin >> A[i];\n		PrTree.Multiply(0, 0, N-1, i, i, A[i]);\n		OSTree.Update(0, 0, N-1, i, i, Mask[A[i]]);\n	}\n}\n\nvoid Solve() {\n	while (Q--) {\n		cin >> cmd >> l >> r; l--; r--;\n		if (cmd == \"MULTIPLY\") {\n			cin >> x;\n			PrTree.Multiply(0, 0, N-1, l, r, x);\n			OSTree.Update(0, 0, N-1, l, r, Mask[x]);\n		}\n		else if (cmd == \"TOTIENT\") {\n			int res = PrTree.Product(0, 0, N-1, l, r);\n			long long SegMask = OSTree.Or(0, 0, N-1, l, r);\n			for (int i=0; i<62; i++) {\n			    if ((SegMask & (1LL << i)) == 0) continue;\n			    res = (1LL * res * (prime[i] - 1)) % Mod;\n			    res = (1LL * res * invPrime[i]) % Mod;\n			}\n			cout << res << endl;\n		}\n	}\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(13,5,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nconst int Mod = 1000000007;\n\nint prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137\n,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293}; // (size = 62)\n\nint modPow(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2 == 0) {a = (1LL * a * a) % Mod; b /= 2;}\n        else {res = (1LL * res * a) % Mod; b -= 1;}\n    }\n    return res;\n}\n\nstruct ProTree {\n	vector<int> Tree, Lazy;\n	ProTree() {}\n	ProTree(int n) {Tree.resize(n*4, 1); Lazy.resize(n*4, 1);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 1) return;\n		Tree[node] = (1LL * Tree[node] * modPow(Lazy[node], (en - st + 1))) % Mod;\n		if (st != en) {\n			Lazy[node*2+1] = (1LL * Lazy[node*2+1] * Lazy[node]) % Mod;\n			Lazy[node*2+2] = (1LL * Lazy[node*2+2] * Lazy[node]) % Mod;\n		}\n		Lazy[node] = 1;\n	}\n	\n	void Multiply(int node, int st, int en, int L, int R, int val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] = (1LL * Lazy[node] * val) % Mod;\n			Propagate(node, st, en); return;\n		}\n		Multiply(node*2+1, st, (st+en)/2+0, L, R, val);\n		Multiply(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (1LL * Tree[node*2+1] * Tree[node*2+2]) % Mod;\n	}\n	\n	int Product(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 1;\n		if (L <= st && en <= R) return Tree[node];\n		int p1 = Product(node*2+1, st, (st+en)/2+0, L, R);\n		int p2 = Product(node*2+2, (st+en)/2+1, en, L, R);\n		return ((1LL * p1 * p2) % Mod);\n	}\n};\n\nstruct OrTree {\n	vector<long long> Tree, Lazy;\n	OrTree() {}\n	OrTree(int n) {Tree.resize(n*4); Lazy.resize(n*4);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 0) return;\n		Tree[node] |= Lazy[node];\n		if (st != en) {\n			Lazy[node*2+1] |= Lazy[node];\n			Lazy[node*2+2] |= Lazy[node];\n		}\n		Lazy[node] = 0;\n	}\n	\n	void Update(int node, int st, int en, int L, int R, long long val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] |= val;\n			Propagate(node, st, en); return;\n		}\n		Update(node*2+1, st, (st+en)/2+0, L, R, val);\n		Update(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (Tree[node*2+1] | Tree[node*2+2]);\n	}\n	\n	long long Or(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 0;\n		if (L <= st && en <= R) return Tree[node];\n		long long p1 = Or(node*2+1, st, (st+en)/2+0, L, R);\n		long long p2 = Or(node*2+2, (st+en)/2+1, en, L, R);\n		return (p1 | p2);\n	}\n};\n\nint N, Q, l, r, x; string cmd;\nvector<int> invPrime(62);\nvector<int> A; ProTree PrTree; OrTree OSTree;\nvector<long long> Mask(301, 0);\n\nvoid PreprocessMask() {\n	for (int z=1; z<=300; z++) {\n		for (int i=0; i<62; i++) {\n			if (z % prime[i] != 0) continue;\n			Mask[z] |= (1LL << i);\n		}\n	}\n}\n\nvoid Input() {\n    for (int i=0; i<62; i++) invPrime[i] = modPow(prime[i], Mod-2); PreprocessMask();\n	cin >> N >> Q; A.resize(N); PrTree = ProTree(N); OSTree = OrTree(N);\n	for (int i=0; i<N; i++) {\n		cin >> A[i];\n		PrTree.Multiply(0, 0, N-1, i, i, A[i]);\n		OSTree.Update(0, 0, N-1, i, i, Mask[A[i]]);\n	}\n}\n\nvoid Solve() {\n	while (Q--) {\n		cin >> cmd >> l >> r; l--; r--;\n		if (cmd == \"MULTIPLY\") {\n			cin >> x;\n			PrTree.Multiply(0, 0, N-1, l, r, x);\n			OSTree.Update(0, 0, N-1, l, r, Mask[x]);\n		}\n		else if (cmd == \"TOTIENT\") {\n			int res = PrTree.Product(0, 0, N-1, l, r);\n			long long SegMask = OSTree.Or(0, 0, N-1, l, r);\n			for (int i=0; i<62; i++) {\n			    if ((SegMask & (1LL << i)) == 0) continue;\n			    res = (1LL * res * (prime[i] - 1)) % Mod;\n			    res = (1LL * res * invPrime[i]) % Mod;\n			}\n			cout << res << endl;\n		}\n	}\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;\n}'),(14,5,'C++',_binary '#pragma comment(linker, \"/stack:247474112\")\n#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n\nconst int Mod = 1000000007;\n\nint prime[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137\n,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293}; // (size = 62)\n\nint modPow(int a, int b) {\n    if (b == 0) return 1;\n    int tmp = modPow(a, b/2);\n    if (b % 2 == 0) return ((1LL * tmp * tmp) % Mod);\n    return ((((1LL * tmp * tmp) % Mod) * a) % Mod);\n}\n\nstruct ProTree {\n	vector<int> Tree, Lazy;\n	ProTree() {}\n	ProTree(int n) {Tree.resize(n*4, 1); Lazy.resize(n*4, 1);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 1) return;\n		Tree[node] = (1LL * Tree[node] * modPow(Lazy[node], (en - st + 1))) % Mod;\n		if (st != en) {\n			Lazy[node*2+1] = (1LL * Lazy[node*2+1] * Lazy[node]) % Mod;\n			Lazy[node*2+2] = (1LL * Lazy[node*2+2] * Lazy[node]) % Mod;\n		}\n		Lazy[node] = 1;\n	}\n	\n	void Multiply(int node, int st, int en, int L, int R, int val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] = (1LL * Lazy[node] * val) % Mod;\n			Propagate(node, st, en); return;\n		}\n		Multiply(node*2+1, st, (st+en)/2+0, L, R, val);\n		Multiply(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (1LL * Tree[node*2+1] * Tree[node*2+2]) % Mod;\n	}\n	\n	int Product(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 1;\n		if (L <= st && en <= R) return Tree[node];\n		int p1 = Product(node*2+1, st, (st+en)/2+0, L, R);\n		int p2 = Product(node*2+2, (st+en)/2+1, en, L, R);\n		return ((1LL * p1 * p2) % Mod);\n	}\n};\n\nstruct OrTree {\n	vector<long long> Tree, Lazy;\n	OrTree() {}\n	OrTree(int n) {Tree.resize(n*4); Lazy.resize(n*4);}\n	\n	void Propagate(int node, int st, int en) {\n		if (Lazy[node] == 0) return;\n		Tree[node] |= Lazy[node];\n		if (st != en) {\n			Lazy[node*2+1] |= Lazy[node];\n			Lazy[node*2+2] |= Lazy[node];\n		}\n		Lazy[node] = 0;\n	}\n	\n	void Update(int node, int st, int en, int L, int R, long long val) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return;\n		if (L <= st && en <= R) {\n			Lazy[node] |= val;\n			Propagate(node, st, en); return;\n		}\n		Update(node*2+1, st, (st+en)/2+0, L, R, val);\n		Update(node*2+2, (st+en)/2+1, en, L, R, val);\n		Tree[node] = (Tree[node*2+1] | Tree[node*2+2]);\n	}\n	\n	long long Or(int node, int st, int en, int L, int R) {\n		Propagate(node, st, en);\n		if (st > en || en < L || R < st) return 0;\n		if (L <= st && en <= R) return Tree[node];\n		long long p1 = Or(node*2+1, st, (st+en)/2+0, L, R);\n		long long p2 = Or(node*2+2, (st+en)/2+1, en, L, R);\n		return (p1 | p2);\n	}\n};\n\nint N, Q, l, r, x; string cmd;\nvector<int> invPrime(62);\nvector<int> A; ProTree PrTree; OrTree OSTree;\nvector<long long> Mask(301, 0);\n\nvoid PreprocessMask() {\n	for (int z=1; z<=300; z++) {\n		for (int i=0; i<62; i++) {\n			if (z % prime[i] != 0) continue;\n			Mask[z] |= (1LL << i);\n		}\n	}\n}\n\nvoid Input() {\n    for (int i=0; i<62; i++) invPrime[i] = modPow(prime[i], Mod-2); PreprocessMask();\n	cin >> N >> Q; A.resize(N); PrTree = ProTree(N); OSTree = OrTree(N);\n	for (int i=0; i<N; i++) {\n		cin >> A[i];\n		PrTree.Multiply(0, 0, N-1, i, i, A[i]);\n		OSTree.Update(0, 0, N-1, i, i, Mask[A[i]]);\n	}\n}\n\nvoid Solve() {\n	while (Q--) {\n		cin >> cmd >> l >> r; l--; r--;\n		if (cmd == \"MULTIPLY\") {\n			cin >> x;\n			PrTree.Multiply(0, 0, N-1, l, r, x);\n			OSTree.Update(0, 0, N-1, l, r, Mask[x]);\n		}\n		else if (cmd == \"TOTIENT\") {\n			int res = PrTree.Product(0, 0, N-1, l, r);\n			long long SegMask = OSTree.Or(0, 0, N-1, l, r);\n			for (int i=0; i<62; i++) {\n			    if ((SegMask & (1LL << i)) == 0) continue;\n			    res = (1LL * res * (prime[i] - 1)) % Mod;\n			    res = (1LL * res * invPrime[i]) % Mod;\n			}\n			cout << res << endl;\n		}\n	}\n}\n\nint main(int argc, char* argv[]) {\n	ios_base::sync_with_stdio(0); cin.tie(NULL);\n	Input(); Solve(); return 0;;\n}'),(15,1,'Java',_binary 'import java.util.*;\n\npublic class Grapes{\n\n		\n\n	public static void main(String[] args) {\n		\n		Scanner myScanner = new Scanner(System.in);\n		int totalDimitry, totalMichael;\n		//vatos\n		//andrew solo come verdes\n		int andrew = myScanner.nextInt();\n		//dimitry solo come verdes y morados\n		int dimitry = myScanner.nextInt();\n		//michael come de todo\n		int michael = myScanner.nextInt();\n		int total = andrew + dimitry + michael;\n\n\n		//uvas de cada caja\n		int verde = myScanner.nextInt();\n		int morado = myScanner.nextInt();\n		int negro = myScanner.nextInt();\n		int totalUvas = verde + morado + negro;\n\n		if(total <= totalUvas){\n			if(verde-andrew >= 0 ){\n				verde = verde - andrew;\n				totalDimitry = verde + morado;\n				if(totalDimitry-dimitry >= 0){\n					totalDimitry = totalDimitry - dimitry;\n					totalMichael = totalDimitry + negro;\n					if(totalMichael-michael >= 0){\n						System.out.println(\"YES\");\n					}\n					else{\n						System.out.println(\"NO\");\n					}\n				}\n				else{\n					System.out.println(\"NO\");\n				}\n			}					\n			else{\n				System.out.println(\"NO\");\n			}\n		}\n		else\n			System.out.println(\"NO\");\n			\n	}\n\n}\n\n\n	 		 		 	  		   							    		'),(16,1,'Java',_binary 'import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Grapes {\n	\n	public static void grapes(int[] w, int[] h) {\n		String ans = \"NO\";	\n		if(w[0]<=h[0]) {\n			if(w[0]+w[1]<=h[0]+h[1]) {\n				if(w[0]+w[1]+w[2]<=h[0]+h[1]+h[2]) {\n					ans=\"YES\";\n				}\n			}\n		}\n		System.out.println(ans);\n\n\n	}\n\n	public static void main(String[] args) {\n//		int[] w= {79,4,4};\n//		int[] h= {81,3,2};\n//		grapes(w,h);\n		String ws,hs;\n		String[] wa,ha;\n		int[] w,h;\n		BufferedReader br= new BufferedReader(new InputStreamReader(System.in));\n		try {\n			while((ws=br.readLine())!=null) {\n				wa=ws.split(\" \");\n				hs=br.readLine();\n				ha=hs.split(\" \");\n				w=new int[3];\n				h=new int[3];\n				for(int i=0;i<ha.length;i++) {\n					w[i]=Integer.parseInt(wa[i]);\n					h[i]=Integer.parseInt(ha[i]);\n					\n				}\n				grapes(w,h);\n			}\n			\n			\n		}catch(IOException e) {\n			System.out.println(e);\n		}\n\n	}\n\n}\n		        	     	 		 	   	'),(17,1,'Java',_binary 'import java.util.Scanner;\npublic class Grapes{\n	public static void main(String[] args) {\n		Scanner sc = new Scanner(System.in);\n		int andrewAComer = sc.nextInt();\n		int dimitryAComer = sc.nextInt();\n		int michalAComer = sc.nextInt();\n		int uvasVerdes = sc.nextInt();\n		int uvasMoradas = sc.nextInt();\n		int uvasNegras = sc.nextInt();\n		if (andrewAComer<=uvasVerdes) { //si hay suficientes uvas verdes\n			while(andrewAComer>0){\n				andrewAComer--;\n				uvasVerdes--;\n			}\n			if ((uvasVerdes+uvasMoradas)>=dimitryAComer) {\n				while(dimitryAComer>0){\n					if (uvasVerdes>0) { //si hay uvas verdes\n						uvasVerdes--;\n						dimitryAComer--;\n					}\n					else if (uvasMoradas>0) { //si no, si hay moradas para dimitry\n						uvasMoradas--;\n						dimitryAComer--;\n					}\n					else{\n						System.out.println(\"NO\");\n						break;\n					}\n				}\n				if ((uvasVerdes+uvasMoradas+uvasNegras)>=michalAComer) {\n					while(michalAComer>0){\n						if (uvasVerdes>0) { //si hay uvas verdes\n							uvasVerdes--;\n							michalAComer--;\n						}\n						else if (uvasMoradas>0) { //si no, si hay moradas para dimitry\n							uvasMoradas--;\n							michalAComer--;\n						}\n						else if (uvasNegras>0) { //si no, si hay moradas para dimitry\n							uvasNegras--;\n							michalAComer--;\n						}\n						else{\n							System.out.println(\"NO\");\n							break;\n						}\n					}\n					if (andrewAComer == 0 && dimitryAComer == 0 && michalAComer ==0) {\n						System.out.println(\"YES\");\n					}\n					else\n						System.out.println(\"NO\");\n				}\n				else\n					System.out.println(\"NO\");\n			}\n			else\n				System.out.println(\"NO\");\n		}\n		else\n			System.out.println(\"NO\");\n	}	\n}\n		 					 	 	 		 		  	 	  		 			'),(18,1,'Java',_binary 'import java.util.Scanner;\n\npublic class B {\n\n	public static void main(String[] args) {\n\n		Scanner sc = new Scanner(System.in);\n		\n		boolean oiea=true;\n		\n		int x=sc.nextInt(),\n			y=sc.nextInt(),\n			z=sc.nextInt();\n		\n		int g=sc.nextInt(),\n			p=sc.nextInt(),\n			b=sc.nextInt();\n		\n		if(g>=x) {\n			g-=x;\n			x=0;\n		}else {\n			oiea=false;\n		}\n		//System.out.println(g);\n		while (b>0 && z>0) {\n			z--;\n			b--;\n		}\n		\n		//System.out.println(g);\n		//System.out.println(p);\n		\n		int faltantes=y+z;\n		\n		if (faltantes-p-g<=0 && oiea) {\n			System.out.println(\"YES\");\n		}else {\n			System.out.println(\"NO\");\n		}\n		\n	}\n\n}\n				  		 				 		 	 	   						 	'),(19,2,'Java',_binary 'import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    \n    \n    static int N = (int)2e5;\n    static InputReader in;\n    static PrintWriter out;\n    \n    static class Pair implements Comparable<Pair>{\n        int x,id;\n        \n        public Pair(int x,int id) {\n            this.x = x;this.id = id;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            // TODO Auto-generated method stub\n            return o.x-this.x;\n        }\n        \n    }\n        \n    public static void main(String[] args) throws IOException{\n        //InputStream ins = new FileInputStream(\"E:\\\\rush.txt\");\n        InputStream ins = System.in;\n        in = new InputReader(ins);\n        out = new PrintWriter(System.out);\n        //code start from here\n        new Task().solve(in, out);\n        out.close();\n    }\n    \n    \n    static class Task{\n        public void solve(InputReader in,PrintWriter out) {\n            int n,m,k;\n            int []a = new int [N+10];\n            int []tag = new int [N+10];\n            Pair []b = new Pair[N+10];\n            n = in.nextInt();m = in.nextInt();k = in.nextInt();\n            for (int i = 1;i <= n;i++) a[i] = in.nextInt();\n            for (int i = 1;i <= n;i++) {\n                b[i] = new Pair(a[i],i);\n            }\n            Arrays.sort(b, 1,n+1);\n            long ans1 = 0;\n            for (int i = 1;i <=m*k;i++) {\n                tag[b[i].id]= 1;\n                ans1 = ans1 + b[i].x;\n            }\n            out.println(ans1);\n            int cnt = 0;\n            int cnt2 = 0;\n            for (int i = 1;i <= n;i++){\n                if (tag[i]==1) {\n                    cnt++;\n                    if (cnt==m) {\n                        cnt = 0;\n                        out.print(i+\" \");\n                        cnt2++;\n                        if (cnt2==k-1){\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    \n\n    static class InputReader{\n        public BufferedReader br;\n        public StringTokenizer tokenizer;\n        \n        public InputReader(InputStream ins) {\n            br = new BufferedReader(new InputStreamReader(ins));\n            tokenizer = null;\n        }\n        \n        public String next(){\n            while (tokenizer==null || !tokenizer.hasMoreTokens()) {\n                try {\n                tokenizer = new StringTokenizer(br.readLine());\n                }catch(IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}'),(20,2,'Java',_binary '// package Greedy;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\n\npublic class ArrayPartitioning {\n    public static void main(String[] args)throws IOException {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        String line[]=br.readLine().split(\" \");\n        int n=Integer.parseInt(line[0]);\n        int m=Integer.parseInt(line[1]);\n        int k=Integer.parseInt(line[2]);\n        int a[]=new int[n];\n        line=br.readLine().split(\" \");\n        ArrayList<Integer> arr=new ArrayList<>();\n        for(int i=0;i<n;i++){\n            a[i]=Integer.parseInt(line[i]);\n            arr.add(a[i]);\n        }\n        HashMap<Integer,Integer> map=new HashMap<>();\n        Collections.sort(arr);\n        long sum=0;\n//        int count2=0;\n        for(int i=arr.size()-1;i>=arr.size()-m*k;i--){\n            sum+=arr.get(i);\n            if(!map.containsKey(arr.get(i)))\n                map.put(arr.get(i),1);\n            else{\n                map.put(arr.get(i),map.get(arr.get(i))+1);\n            }\n//            count2++;\n        }\n//        System.out.println(count2);\n        ArrayList<Integer> indices=new ArrayList<>();\n        int index=0;\n        for(int i=0;i<m*k;i+=m){\n            int count=0;\n//            long sum2=0;\n            for(int j=index;j<n;j++){\n                if(map.containsKey(a[j])&&map.get(a[j])!=0){\n//                    System.out.print(a[j]+\" \");\n//                    sum2+=a[j];\n                    count++;\n                    map.put(a[j],map.get(a[j])-1);\n                }\n                if(count==m){\n                    index=j+1;\n                    indices.add(index);\n                    break;\n                }\n            }\n//            System.out.println(sum2);\n        }\n//        System.out.println();\n        System.out.println(sum);\n        for(int i=0;i<k-1;i++){\n            System.out.print(indices.get(i)+\" \");\n        }\n        System.out.println();\n    }\n}'),(21,2,'Java',_binary 'import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.util.Collections;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        YetAnotherSubarray solver = new YetAnotherSubarray();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class YetAnotherSubarray {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int N = in.nextInt();\n            int M = in.nextInt();\n            int K = in.nextInt();\n            ArrayList<Integer> arr = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                arr.add(in.nextInt());\n            }\n            ArrayList<Integer> original = new ArrayList<>(arr);\n            Collections.sort(arr, Collections.reverseOrder());\n            YetAnotherSubarray.Multiset set = new YetAnotherSubarray.Multiset();\n            for (int i = 0; i < K * M; i++) {\n                set.add(arr.get(i));\n            }\n            int p = 0;\n            long sum = 0;\n            ArrayList<Integer> partition = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                if (set.contains(original.get(i))) {\n                    sum += original.get(i);\n                    p++;\n                    set.remove(original.get(i));\n                }\n                if (p == M) {\n                    p = 0;\n                    partition.add(i + 1);\n                }\n            }\n            out.println(sum);\n            for (int i = 0; i < K - 1; i++) {\n                out.print(partition.get(i) + \" \");\n            }\n        }\n\n        static class Multiset {\n            HashMap<Integer, Integer> counts = new HashMap<>();\n\n            void add(int val) {\n                counts.putIfAbsent(val, 0);\n                counts.replace(val, counts.get(val) + 1);\n            }\n\n            void remove(int val) {\n                counts.replace(val, counts.get(val) - 1);\n                if (counts.get(val) == 0) {\n                    counts.remove(val);\n                }\n            }\n\n            boolean contains(int val) {\n                return (counts.containsKey(val));\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n '),(22,2,'Java',_binary 'import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n         FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in)); }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try{ st = new StringTokenizer(br.readLine()); }\n                catch (IOException  e) { e.printStackTrace(); } }\n            return st.nextToken(); }\n        int nextInt() { return Integer.parseInt(next()); }\n        long nextLong() { return Long.parseLong(next()); }\n        double nextDouble() { return Double.parseDouble(next()); }\n        String nextLine()  {\n            String str = \"\";\n            try{ str = br.readLine(); }\n            catch (IOException e) { e.printStackTrace(); }\n            return str; }\n    }\n\n    public static void main(String[] args) {\n         FastReader ip=new FastReader();\n         OutputStream outputStream= System.out;\n         PrintWriter out=new PrintWriter(outputStream);\n\n         int n=ip.nextInt();\n         int m=ip.nextInt();\n         int k=ip.nextInt();\n         long[] arr =new long[n];\n         long[] temp=new long[n];\n         for(int i=0;i<n;i++){\n             arr[i]=ip.nextLong();\n             temp[i]=arr[i];\n         }\n         Arrays.sort(arr);\n         HashMap<Long,Integer> hm=new HashMap<>();\n         long sum=0; int c=0;\n         for(int i=arr.length-1;i>=0;i--){\n             sum+=arr[i];\n             c++;\n            if(hm.containsKey(arr[i])){\n                hm.put(arr[i],hm.get(arr[i])+1);\n            }else{\n                hm.put(arr[i],1);\n            }\n             if(c==k*m){\n                 break;\n             }\n         }\n\n\n         out.println(sum);\n         c=0;\n         int check=0;\n         for(int i=0;i<n;i++){\n             if(hm.containsKey(temp[i]) && hm.get(temp[i])!=0 ){\n                 c++;\n                 hm.put(temp[i],hm.get(temp[i])-1);\n             }\n             if(c==m){\n                 out.print(i+1+\" \");\n                 c=0;\n                 check++;\n             }\n\n             if(check==k-1){\n                 break;\n             }\n         }\n         out.close();\n    }\n}'),(23,3,'Java',_binary 'import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class floodFill {\n	\n	static int firstMatrix[][];\n	static int arr[];\n\n	public static void main(String args[]) {\n		\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        arr=new int[n+1];\n        int m=0;\n        for (int i=1;i<=n;i++){\n            int x=sc.nextInt();\n            if (arr[m]!=x)arr[++m]=x;\n        }\n        n=m;\n        firstMatrix=new int[n+1][n+1];\n        for (int a[]:firstMatrix)Arrays.fill(a,-1);\n        System.out.println(firstMatrix(1,n));\n    }\n    static int firstMatrix(int l,int r){\n        if (firstMatrix[l][r]!=-1)return firstMatrix[l][r];\n        if (l>=r)return firstMatrix[l][r]=0;\n        if (arr[l]==arr[r])return firstMatrix[l][r]= 1+firstMatrix(l+1,r-1);\n        return firstMatrix[l][r]=1+Math.min(firstMatrix(l+1,r),firstMatrix(l,r-1));\n    }\n\n}\n 		 	 	 	  		 	    		 			 	 		'),(24,3,'Java',_binary 'import java.io.*;\nimport java.util.*;\npublic final class code\n{\n	static int n,c[],maxc,dp[][];\n	static int turns(int left,int right)\n	{\n		if(dp[left][right]!=-1)\n			return dp[left][right];	\n		int ans=0;\n		if(left==0 && right==maxc+1)\n			ans=0;\n		else if(left==0)\n			ans=1+turns(left,right+1);\n		else if(right==maxc+1)\n			ans=1+turns(left-1,right);\n		else if(c[left]==c[right])\n			ans=1+turns(left-1,right+1);\n		else\n			ans=Math.min(1+turns(left-1,right),1+turns(left,right+1));\n		dp[left][right]=ans;\n		return ans;\n	}\n	static void solve()throws IOException\n	{\n		n=nextInt();\n		c=new int[n+1];\n		//c[1..maxc] is the color of the components 1..maxc \n		maxc=0;\n		c[++maxc]=nextInt();\n		for(int i=2;i<=n;i++)\n		{\n			int x=nextInt();\n			if(x==c[maxc])\n				continue;\n			else\n				c[++maxc]=x;\n		}\n		dp=new int[maxc+2][maxc+2];\n		for(int i=0;i<=maxc+1;i++)\n		{\n			for(int j=0;j<=maxc+1;j++)\n				dp[i][j]=-1;\n		}\n		int max=(int)(1e9);\n		for(int i=1;i<=maxc;i++)\n		{\n			//i is the starting component\n			int curr=turns(i,i)-1;\n			//out.println(curr);\n			max=Math.min(curr,max);\n		}\n		out.println(max);\n	}\n	\n\n\n\n\n	\n	///////////////////////////////////////////////////////////\n	static BufferedReader br;\n	static StringTokenizer st;\n	static PrintWriter out;\n	static String nextToken()throws IOException\n	{\n		while(st==null || !st.hasMoreTokens())\n			st=new StringTokenizer(br.readLine());\n		return st.nextToken();\n	}\n	static String nextLine()throws IOException\n	{\n		return br.readLine();\n	}\n	static int nextInt()throws IOException\n	{\n		return Integer.parseInt(nextToken());\n	}\n	static long nextLong()throws IOException\n	{\n		return Long.parseLong(nextToken());\n	}\n	static double nextDouble()throws IOException\n	{\n		return Double.parseDouble(nextToken());\n	}\n	public static void main(String args[])throws IOException\n	{\n		br=new BufferedReader(new InputStreamReader(System.in));\n		out=new PrintWriter(new BufferedOutputStream(System.out));\n		solve();\n		out.close();\n	}\n}'),(25,3,'Java',_binary '// Working program with FastReader\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Akikaze\n{\n	static int n;\n	static int func(int i, int j, int k)\n	{\n		return (i * n * 2 + j * 2 + k);\n	}\n	public static void main(String[] args) \n	{\n		int Inf = 32767;\n		FastReader sc = new FastReader();\n		n = sc.nextInt(); int[] c = new int[n];\n		for (int i=0; i<n; i++) c[i] = sc.nextInt();\n		\n		int[] dp = new int[n*n*2];\n		for (int i=0; i<n; i++) {\n			for (int j=0; j<n; j++) {\n				for (int k=0; k<2; k++) {\n					if (i == j) dp[func(i,j,k)] = 0;\n					else dp[func(i,j,k)] = Inf;\n				}\n			}\n		}\n		for (int Len=1; Len<n; Len++) {\n			for (int i=0; i<=n-Len; i++) {\n				int j = i + Len - 1;\n				for (int dir=0; dir<2; dir++) {\n					int col = c[i];\n					if (dir > 0) col = c[j];\n					int diff_i = 0; if (i > 0) {if (col != c[i-1]) diff_i = 1;}\n					int diff_j = 0; if (j+1 < n) {if (col != c[j+1]) diff_j = 1;}\n					if (i > 0 && dp[func(i,j,dir)] + diff_i < dp[func(i-1,j,0)]) {\n						dp[func(i-1,j,0)] = dp[func(i,j,dir)] + diff_i;\n					}\n					if (j+1 < n && dp[func(i,j,dir)] + diff_j < dp[func(i,j+1,1)]) {\n						dp[func(i,j+1,1)] = dp[func(i,j,dir)] + diff_j;\n					}\n				}\n			}\n		}\n		System.out.println(Math.min(dp[func(0,n-1,0)], dp[func(0,n-1,1)]));\n	}\n\n	static class FastReader \n	{ \n		BufferedReader br; \n		StringTokenizer st; \n\n		public FastReader() \n		{ \n			br = new BufferedReader(new\n					InputStreamReader(System.in)); \n		} \n\n		String next() \n		{ \n			while (st == null || !st.hasMoreElements()) \n			{ \n				try\n				{ \n					st = new StringTokenizer(br.readLine()); \n				} \n				catch (IOException e) \n				{ \n					e.printStackTrace(); \n				} \n			} \n			return st.nextToken(); \n		} \n\n		int nextInt() \n		{ \n			return Integer.parseInt(next()); \n		} \n\n		long nextLong() \n		{ \n			return Long.parseLong(next()); \n		} \n\n		double nextDouble() \n		{ \n			return Double.parseDouble(next()); \n		} \n\n		String nextLine() \n		{ \n			String str = \"\"; \n			try\n			{ \n				str = br.readLine(); \n			} \n			catch (IOException e) \n			{ \n				e.printStackTrace(); \n			} \n			return str; \n		} \n	}\n}\n \n\n	\n\n\n	\n\n	 \n\n \n\n\n	'),(26,3,'Java',_binary '// Working program with FastReader\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\nimport java.lang.*;\n\npublic class Akikaze\n{\n	static int n;\n	static int func(int i, int j, int k)\n	{\n		return (i * n * 2 + j * 2 + k);\n	}\n	public static void main(String[] args) \n	{\n		int Inf = 32767;\n		FastReader sc = new FastReader();\n		n = sc.nextInt(); int[] c = new int[n];\n		for (int i=0; i<n; i++) c[i] = sc.nextInt();\n		\n		int[] dp = new int[n*n*2];\n		for (int i=0; i<n; i++) {\n			for (int j=0; j<n; j++) {\n				for (int k=0; k<2; k++) {\n					if (i == j) dp[func(i,j,k)] = 0;\n					else dp[func(i,j,k)] = Inf;\n				}\n			}\n		}\n		for (int Len=1; Len<n; Len++) {\n			for (int i=0; i<=n-Len; i++) {\n				int j = i + Len - 1;\n				for (int dir=0; dir<2; dir++) {\n					int col = c[i];\n					if (dir > 0) col = c[j];\n					int diff_i = 0; if (i > 0) {if (col != c[i-1]) diff_i = 1;}\n					int diff_j = 0; if (j+1 < n) {if (col != c[j+1]) diff_j = 1;}\n					if (i > 0 && dp[func(i,j,dir)] + diff_i < dp[func(i-1,j,0)]) {\n						dp[func(i-1,j,0)] = dp[func(i,j,dir)] + diff_i;\n					}\n					if (j+1 < n && dp[func(i,j,dir)] + diff_j < dp[func(i,j+1,1)]) {\n						dp[func(i,j+1,1)] = dp[func(i,j,dir)] + diff_j;\n					}\n				}\n			}\n		}\n		System.out.println(Math.min(dp[func(0,n-1,0)], dp[func(0,n-1,1)]));\n	}\n\n	static class FastReader \n	{ \n		BufferedReader br; \n		StringTokenizer st; \n\n		public FastReader() \n		{ \n			br = new BufferedReader(new\n					InputStreamReader(System.in)); \n		} \n\n		String next() \n		{ \n			while (st == null || !st.hasMoreElements()) \n			{ \n				try\n				{ \n					st = new StringTokenizer(br.readLine()); \n				} \n				catch (IOException e) \n				{ \n					e.printStackTrace(); \n				} \n			} \n			return st.nextToken(); \n		} \n\n		int nextInt() \n		{ \n			return Integer.parseInt(next()); \n		} \n\n		long nextLong() \n		{ \n			return Long.parseLong(next()); \n		} \n\n		double nextDouble() \n		{ \n			return Double.parseDouble(next()); \n		} \n\n		String nextLine() \n		{ \n			String str = \"\"; \n			try\n			{ \n				str = br.readLine(); \n			} \n			catch (IOException e) \n			{ \n				e.printStackTrace(); \n			} \n			return str; \n		} \n	}\n}\n	\n\n \n\n \n\n	  \n			\n\n	'),(27,4,'Java',_binary 'import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int n = ni();\n        long lo = 0, hi = (long)1e9;\n        int qc = 60;\n        while(lo < hi){\n            long mid = lo+(hi-lo)/2;qc--;\n            if(q(mid))lo = mid+1;\n            else hi = mid;\n        }\n        long d = 0;\n        Random r = new Random();\n        Map<Integer, Long> a = new TreeMap<>();\n        for(int i = 0; i< 120 && qc>0; i++){\n            int p = r.nextInt(n)+1;\n            if(a.containsKey(p))continue;\n            pni(\"? \"+p);qc--;\n            a.put(p, nl());\n        }\n        for(long l:a.values())\n            for(long m:a.values())\n                d = gcd(d, Math.abs(l-m));\n        \n        long f = lo-d*(n-1);\n        pn(\"! \"+f+\" \"+d);\n        \n    }\n    boolean q(long x) throws Exception{\n        pni(\"> \"+x);\n        return ni()==1;\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    long IINF = (long)1e18, mod = (long)1e9+7;\n    final int INF = (int)1e9, MX = (int)2e5+5;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;\n    static boolean multipleTC = false, memory = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}'),(28,4,'Java',_binary 'import java.awt.image.AreaAveragingScaleFilter;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.sql.Array;\nimport java.util.*;\n\nimport java.util.StringTokenizer;\npublic class l{\n    static ArrayList<Integer> primes;\n    static int[] isComposite;\n\n    static void sieve(int N)	// O(N log log N)\n    {\n        isComposite = new int[N+1];\n        isComposite[0] = isComposite[1] = 1;			// 0 indicates a prime number\n        primes = new ArrayList<Integer>();\n\n        for (int i = 2; i <= N; ++i) 					//can loop till i*i <= N if primes array is not needed O(N log log sqrt(N))\n            if (isComposite[i] == 0) 					//can loop in 2 and odd integers for slightly better performance\n            {\n                primes.add(i);\n                if(1l * i * i <= N)\n                    for (int j = i * i; j <= N; j += i)	// j = i * 2 will not affect performance too much, may alter in modified sieve\n                        isComposite[j] = 1;\n            }\n    }\n\n\n    public static void main (String[]args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        int min =0;\n        int max =(int)1e9;\n        int ans =0;\n        int c =0;\n        while (min<=max){\n            int mid=min+max>>1;\n            System.out.println(\"> \"+mid);\n            c++;\n            int m = sc.nextInt();\n            if (m==0){\n                ans=mid;\n                max=mid-1;\n            }\n            else {\n                min=mid+1;\n            }\n        }\n        //System.out.println(ans);\n        HashSet<Integer>used= new HashSet<>();\n        ArrayList<Integer>val= new ArrayList<>();\n        c=Math.max(c,60-n);\n        while (c<60){\n            int x = (int)(Math.random()*n)+1;\n            if (!used.contains(x)){\n                System.out.println(\"? \"+x);\n                val.add(sc.nextInt());\n                c++;\n                used.add(x);\n            }\n        }\n        val.add(ans);\n        int g =0;\n        for (int a:val){\n            for (int b: val){\n                g = gcd(g,Math.abs(a-b));\n            }\n        }\n        pw.println(\"! \"+(ans-((n-1)*g))+\" \"+g);\n        pw.flush();\n    }\n    static int gcd(int a ,int b){\n        if (a==0)return b;\n        return gcd(b%a,a);\n    }\n    static class Scanner\n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n\n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n\n        public double nextDouble() throws IOException\n        {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if(x.charAt(0) == \'-\')\n            {\n                neg = true;\n                start++;\n            }\n            for(int i = start; i < x.length(); i++)\n                if(x.charAt(i) == \'.\')\n                {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                }\n                else\n                {\n                    sb.append(x.charAt(i));\n                    if(dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg?-1:1);\n        }\n\n        public boolean ready() throws IOException {return br.ready();}\n\n\n    }\n}'),(29,4,'Java',_binary 'import java.io.*;\nimport java.util.*;\n\npublic class Main{\n    public static void main(String[] args){\n        try {\n            new Main().solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    InputReader in = new InputReader(System.in);\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    private void solve() throws Exception{\n        int n=in.nextInt();\n        int l=0,r=1000000000;\n        while(l<r){\n            int mid=(l+r)>>>1;\n            print(\"> \"+mid);\n            int x=in.nextInt();\n            if(x==1)l=mid+1;\n            else r=mid;\n        }\n        int[]a=new int[20];\n        int[]x=new int[n+1];\n        for(int i=1;i<=n;i++)x[i]=i;\n        Random rnd=new Random();\n        for(int i=n;i>=2;i--){\n            int index=rnd.nextInt(i-1)+1;\n            int tmp=x[i];\n            x[i]=x[index];\n            x[index]=tmp;\n        }\n        for(int i=1;i<=Math.min(n,a.length);i++){\n            print(\"? \"+x[i]);\n            a[i-1]=in.nextInt();\n        }\n        Arrays.sort(a,0,Math.min(n,a.length));\n        int d=a[1]-a[0];\n        for(int i=2;i<Math.min(n,a.length);i++){\n            for(int j=0;j<i;j++) {\n                d = gcd(d, a[i] - a[j]);\n            }\n        }\n        print(\"! \"+(l-(n-1)*d)+\" \"+d);\n        out.flush();\n    }\n    void print(String s){\n        out.println(s);\n        out.flush();\n    }\n    public static int gcd(int a,int b) {\n        int r;\n        if(b>a){\n            int tmp=b;\n            b=a;\n            a=tmp;\n        }\n        while(b>0) {\n            r=a%b;\n            a=b;\n            b=r;\n        }\n        return a;\n    }\n}\nclass InputReader{\n    StreamTokenizer tokenizer;\n    public InputReader(InputStream stream){\n        tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));\n        tokenizer.ordinaryChars(33,126);\n        tokenizer.wordChars(33,126);\n    }\n    public String next() throws IOException {\n        tokenizer.nextToken();\n        return tokenizer.sval;\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    public boolean hasNext() throws IOException {\n        int res=tokenizer.nextToken();\n        tokenizer.pushBack();\n        return res!=tokenizer.TT_EOF;\n    }\n}'),(30,4,'Java',_binary 'import java.io.*;\nimport java.util.*;\n\npublic class E {\n    static MyScanner sc;\n    static PrintWriter pw;\n\n    public static void main(String[] args) throws Throwable {\n        sc = new MyScanner();\n        pw = new PrintWriter(System.out);\n\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = i + 1;\n        shuffle(a);\n\n        ArrayList<Integer> arr = new ArrayList<>();\n        for (int i = 0; i < Math.min(n, 30); i++) {\n            pw.println(\"? \" + a[i]);\n            pw.flush();\n            arr.add(sc.nextInt());\n        }\n        int g = 0;\n        for (int i = 0; i < arr.size(); i++)\n            for (int j = 0; j < arr.size(); j++)\n                g = gcd(g, Math.abs(arr.get(i) - arr.get(j)));\n        long start = 1, end = (int) 1e9, ans = 0;\n        while (start <= end) {\n            long mid = (start + end) / 2;\n            long last = mid + 1L * (n - 1) * g;\n            if (last > 1e9) {\n                end = mid - 1;\n                continue;\n            }\n            pw.println(\"> \" + (last - 1));\n            pw.flush();\n            int r = sc.nextInt();\n            if (r == 1) {\n                start = mid + 1;\n                ans = mid;\n            } else {\n                end = mid - 1;\n            }\n        }\n        pw.println(\"! \" + ans + \" \" + g);\n\n        pw.flush();\n        pw.close();\n    }\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static void shuffle(int[] a) {\n        Random r = new Random();\n        for (int i = 0; i < a.length; i++) {\n            int x = r.nextInt(a.length);\n            int y = r.nextInt(a.length);\n            int tmp = a[x];\n            a[x] = a[y];\n            a[y] = tmp;\n        }\n    }\n\n    static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}'),(31,5,'Java',_binary 'import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int[] prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n            71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n            167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\n            269, 271, 277, 281, 283, 293};\n    static final int MOD = (int) (1E9 + 7);\n    static long[] inv = new long[305];\n    static long[] mask = new long[305];\n    static int[] a;\n    static int n, q;\n    public static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n        InputReader() {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n        }\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreElements()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n                catch(IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \" \";\n            try {\n                str = reader.readLine();\n            }\n            catch(IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static class Node {\n        long prod;\n        long mask;\n        long lazy1;\n        long lazy2;\n        Node() {\n            prod = lazy1 = 1;\n            mask = lazy2 = 0;\n        }\n    }\n    static Node[] node;\n    static long power(long a, long b) {\n        if (b == 0) return 1;\n        if (b == 1) return a % MOD;\n        long p = power(a, b >> 1);\n        if (b % 2 == 1) return a * p % MOD * p % MOD;\n        else return p * p % MOD;\n    }\n    static void build(int k, int l, int r) {\n        if (l == r) {\n            node[k].prod = a[r];\n            node[k].mask = mask[a[r]];\n            return;\n        }\n        int m = l + r >> 1;\n        build(k << 1, l, m);\n        build(k << 1 | 1, m + 1, r);\n        node[k].prod = node[k << 1].prod * node[k << 1 | 1].prod % MOD;\n        node[k].mask = node[k << 1].mask | node[k << 1 | 1].mask;\n    }\n    static void down(int k, int l, int r) {\n        int m = l + r >> 1;\n        long temp = node[k].lazy1;\n        if (temp != 1) {\n            node[k << 1].prod *= power(temp, m - l + 1);\n            node[k << 1].prod %= MOD;\n            node[k << 1].lazy1 *= temp;\n            node[k << 1].lazy1 %= MOD;\n            node[k << 1 | 1].prod *= power(temp, r - m);\n            node[k << 1 | 1].prod %= MOD;\n            node[k << 1 | 1].lazy1 *= temp;\n            node[k << 1 | 1].lazy1 %= MOD;\n            node[k].lazy1 = 1;\n        }\n        temp = node[k].lazy2;\n        if (temp > 0) {\n            node[k << 1].mask |= temp;\n            node[k << 1].lazy2 |= temp;\n            node[k << 1 | 1].mask |= temp;\n            node[k << 1 | 1].lazy2 |= temp;\n            node[k].lazy2 = 0;\n        }\n    }\n    static void update(int k, int l, int r, int u, int v, int val) {\n        if (v < l || r < u) return;\n        if (u <= l && r <= v) {\n            node[k].prod *= power(val, r - l + 1);\n            node[k].prod %= MOD;\n            node[k].lazy1 *= val;\n            node[k].lazy1 %= MOD;\n            node[k].mask |= mask[val];\n            node[k].lazy2 |= mask[val];\n            return;\n        }\n        down(k, l, r);\n        int m = l + r >> 1;\n        update(k << 1, l, m, u, v, val);\n        update(k << 1 | 1, m + 1, r, u, v, val);\n        node[k].prod = node[k << 1].prod * node[k << 1 | 1].prod % MOD;\n        node[k].mask = node[k << 1].mask | node[k << 1 | 1].mask;\n    }\n    static long getProduct(int k, int l, int r, int u, int v) {\n        if (v < l || r < u) return 1;\n        if (u <= l && r <= v) return node[k].prod;\n        down(k, l, r);\n        int m = l + r >> 1;\n        return getProduct(k << 1, l, m, u, v) * getProduct(k << 1 | 1, m + 1, r, u, v) % MOD;\n    }\n    static long getMask(int k, int l, int r, int u, int v) {\n        if (v < l || r < u) return 0;\n        if (u <= l && r <= v) return node[k].mask;\n        down(k, l, r);\n        int m = l + r >> 1;\n        return getMask(k << 1, l, m, u, v) | getMask(k << 1 | 1, m + 1, r, u, v);\n    }\n    public static void main(String[] args) {\n        //InputReader in = new InputReader();\n        Scanner in = new Scanner(System.in);\n        n = in.nextInt();\n        q = in.nextInt();\n        a = new int[n + 5];\n        node = new Node[16 * n];\n        for (int i = 1 ; i <= 4 * n + 5; i++) node[i] = new Node();\n        for (int i = 1 ; i <= n; i++) {\n            a[i] = in.nextInt();\n        }\n        in.nextLine();\n        for (int i = 2 ; i <= 300; i++) {\n            for (int j = 0 ; j < 62; j++) {\n                if (i % prime[j] == 0) {\n                    mask[i] |= (long) 1 << j;\n                }\n            }\n        }\n        for (int i = 0 ; i < 62; i++) {\n            inv[i] = power(prime[i], MOD - 2);\n        }\n        build(1, 1, n);\n        while (q-- > 0) {\n            String type = in.nextLine();\n            StringTokenizer tokenizer = new StringTokenizer(type, \" \");\n            if (type.charAt(0) == \'M\') {\n                int cnt = 0;\n                int l = 0;\n                int r = 0;\n                int x = 0;\n                while (tokenizer.hasMoreTokens()) {\n                    cnt++;\n                    if (cnt == 1) tokenizer.nextToken();\n                    if (cnt == 2) l = Integer.parseInt(tokenizer.nextToken());\n                    if (cnt == 3) r = Integer.parseInt(tokenizer.nextToken());\n                    if (cnt == 4) x = Integer.parseInt(tokenizer.nextToken());\n                }\n                if (x == 1) continue;\n                update(1, 1, n, l, r, x);\n            }\n            else {\n                int l = 0;\n                int r = 0;\n                int cnt = 0;\n                while (tokenizer.hasMoreTokens()) {\n                    cnt++;\n                    if (cnt == 1) tokenizer.nextToken();\n                    if (cnt == 2) l = Integer.parseInt(tokenizer.nextToken());\n                    if (cnt == 3) r = Integer.parseInt(tokenizer.nextToken());\n                }\n                long res1 = getProduct(1, 1, n, l, r);\n                long res2 = getMask(1, 1, n, l, r);\n                for (int i = 0 ; i < 62; i++) {\n                    if (((res2 >> i) & 1) == 1) {\n                        res1 *= (prime[i] - 1) * inv[i] % MOD;\n                        res1 %= MOD;\n                    }\n                }\n                System.out.println(res1);\n            }\n        }\n    }\n}'),(32,5,'Java',_binary 'import java.io.*;\nimport java.util.*;\n\npublic class F {\n    static class ModularArithmetic {\n        private final int module;\n\n        public ModularArithmetic(int module) {\n            this.module = module;\n        }\n\n        public ModularArithmetic() {\n            this(1_000_000_007);\n        }\n\n        final int sum(int a, int b) {\n            int sum = a + b;\n            return sum >= module ? sum - module : sum;\n        }\n\n        final int product(int a, int b) {\n            return (int)((long)a * b % module);\n        }\n\n        final int power(int x, int k) {\n            int result = 1;\n            while (k > 0) {\n                if (k % 2 == 1) {\n                    result = product(result, x);\n                }\n                x = product(x, x);\n                k /= 2;\n            }\n            return result;\n        }\n\n        final int inverse(int x) {\n            return power(x, module - 2);\n        }\n    }\n\n\n    static class OrSegmentTree {\n        private int size;\n        final private long[] a;\n        final private long[] applyToAll;\n\n        OrSegmentTree(int n) {\n            size = 1;\n            while (size <= n) {\n                size *= 2;\n            }\n            a = new long[2 * size];\n            applyToAll = new long[2 * size];\n        }\n\n        void set(int i, long value) {\n            a[size + i] = value;\n            for (int j = (size + i) / 2; j > 0; j /= 2) {\n                a[j] = a[2 * j] | a[2 * j + 1];\n            }\n        }\n\n        void orOnTheInterval(int l, int r, long mask) {\n            orOnTheInterval(1, l, r, 0, size, mask);\n        }\n\n        private void orOnTheInterval(int i, int l, int r, int li, int ri, long mask) {\n            a[i] |= mask;\n            if (l == li && r == ri) {\n                applyToAll[i] |= mask;\n                return;\n            }\n            int med = (li + ri) / 2;\n            if (r > med) {\n                orOnTheInterval(2 * i + 1, Math.max(l, med), r, med, ri, mask);\n            }\n            if (l < med) {\n                orOnTheInterval(2 * i, l, Math.min(med, r), li, med, mask);\n            }\n        }\n\n        long getOr(int l, int r) {\n            return getOr(1, l, r, 0, size);\n        }\n\n        private long getOr(int i, int l, int r, int li, int ri) {\n            long or = applyToAll[i];\n            if (l == li && r == ri) {\n                return or | a[i];\n            }\n            int med = (li + ri) / 2;\n            if (r > med) {\n                or |= getOr(2 * i + 1, Math.max(l, med), r, med, ri);\n            }\n            if (l < med) {\n                or |= getOr(2 * i, l, Math.min(med, r), li, med);\n            }\n            return or;\n        }\n    }\n\n    static class ProductSegmentTree {\n        private int size;\n        final private int[] a;\n        final private int[] applyToAll;\n        final ModularArithmetic modular = new ModularArithmetic();\n\n        ProductSegmentTree(int n) {\n            size = 1;\n            while (size <= n) {\n                size *= 2;\n            }\n            a = new int[2 * size];\n            applyToAll = new int[2 * size];\n            Arrays.fill(applyToAll, 1);\n        }\n\n        void set(int i, int value) {\n            a[size + i] = value;\n            for (int j = (size + i) / 2; j > 0; j /= 2) {\n                a[j] = modular.product(a[2 * j], a[2 * j + 1]);\n            }\n        }\n\n        void multiplyOnInterval(int l, int r, int value) {\n            multiplyOnInterval(1, l, r, 0, size, value);\n        }\n\n        private void multiplyOnInterval(int i, int l, int r, int li, int ri, int value) {\n            a[i] = modular.product(a[i], modular.power(value, r - l));\n            if (l == li && r == ri) {\n                applyToAll[i] = modular.product(value, applyToAll[i]);\n                return;\n            }\n            int med = (li + ri) / 2;\n            if (r > med) {\n                multiplyOnInterval(2 * i + 1, Math.max(l, med), r, med, ri, value);\n            }\n            if (l < med) {\n                multiplyOnInterval(2 * i, l, Math.min(med, r), li, med, value);\n            }\n        }\n\n        int getProduct(int l, int r) {\n            return getProduct(1, l, r, 0, size);\n        }\n\n        private int getProduct(int i, int l, int r, int li, int ri) {\n            if (l == li && r == ri) {\n                return a[i];\n            }\n            int product = modular.power(applyToAll[i], r - l);\n            int med = (li + ri) / 2;\n            if (r > med) {\n                product = modular.product(product, getProduct(2 * i + 1, Math.max(l, med), r, med, ri));\n            }\n            if (l < med) {\n                product = modular.product(product, getProduct(2 * i, l, Math.min(med, r), li, med));\n            }\n            return product;\n        }\n    }\n\n    static class Naive {\n        final int[][] a;\n        final boolean debug;\n        final List<Integer> primes = new ArrayList<>();\n\n        Naive(int n, boolean debug) {\n            this.debug = debug;\n\n            for (int i = 2; i <= 300; i++) {\n                boolean isPrime = true;\n                for (int j = 2; j * j <= i; j++) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                    }\n                }\n                if (isPrime) {\n                    primes.add(i);\n                }\n            }\n            a = new int[primes.size()][n];\n        }\n\n        void set(int i, int x) {\n            if (!debug) {\n                return;\n            }\n            for (int j = 0; j < primes.size(); j++) {\n                int p = primes.get(j);\n                while (x % p == 0) {\n                    x /= p;\n                    a[j][i]++;\n                }\n            }\n        }\n\n        void multiply(int l, int r, int value) {\n            if (!debug) {\n                return;\n            }\n            for (int i = l; i < r; i++) {\n                set(i, value);\n            }\n        }\n\n        void totient(int l, int r) {\n            if (!debug) {\n                return;\n            }\n            long t = 1;\n            long product = 1;\n            int mod = 1_000_000_007;\n            long mask = 0;\n            for (int j = 0; j < primes.size(); j++) {\n                int p = primes.get(j);\n                int c = 0;\n                for (int i = l; i < r; i++) {\n                    c += a[j][i];\n                }\n                if (c > 0) {\n                    System.out.println(\"prime: \" + p);\n                    mask |= 1 << j;\n                    t *= p - 1;\n                    product *= p;\n                    for (int i = 1; i < c; i++) {\n                        t *= p;\n                        product *= p;\n                    }\n                }\n            }\n            System.out.printf(\"naive: %d (product=%d,mask=%d)\\n\", (t % mod), product, mask);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        try (Input input = new StandardInput(); PrintWriter writer = new PrintWriter(System.out)) {\n            List<Integer> primes = new ArrayList<>();\n            for (int i = 2; i <= 300; i++) {\n                boolean isPrime = true;\n                for (int j = 2; j * j <= i; j++) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                    }\n                }\n                if (isPrime) {\n                    primes.add(i);\n                }\n            }\n            long[] primeMask = new long[301];\n            for (int i = 1; i <= 300; i++) {\n                for (int j = 0; j < primes.size(); j++) {\n                    if (i % primes.get(j) == 0) {\n                        primeMask[i] |= 1L << j;\n                    }\n                }\n            }\n            int[] multiplier = new int[64];\n            ModularArithmetic modular = new ModularArithmetic();\n            for (int i = 0; i < primes.size(); i++) {\n                int p = primes.get(i);\n                multiplier[i] = modular.product(p - 1, modular.inverse(p));\n            }\n\n            int n = input.nextInt(), q = input.nextInt();\n            ProductSegmentTree productSegmentTree = new ProductSegmentTree(n);\n            OrSegmentTree orSegmentTree = new OrSegmentTree(n);\n            Naive naive = new Naive(n, false);\n            for (int i = 0; i < n; i++) {\n                int x = input.nextInt();\n                naive.set(i, x);\n                productSegmentTree.set(i, x);\n                orSegmentTree.set(i, primeMask[x]);\n            }\n            for (int qi = 0; qi < q; qi++) {\n                if (input.next().equals(\"MULTIPLY\")) {\n                    int l = input.nextInt() - 1;\n                    int r = input.nextInt();\n                    int x = input.nextInt();\n                    naive.multiply(l, r, x);\n                    productSegmentTree.multiplyOnInterval(l, r, x);\n                    orSegmentTree.orOnTheInterval(l, r, primeMask[x]);\n                } else {\n                    int l = input.nextInt() - 1;\n                    int r = input.nextInt();\n                    naive.totient(l, r);\n                    int product = productSegmentTree.getProduct(l, r);\n                    long mask = orSegmentTree.getOr(l, r);\n                    for (int i = 0; i < 64; i++) {\n                        if (mask % 2 == 1) {\n                            product = modular.product(product, multiplier[i]);\n                        }\n                        mask /= 2;\n                    }\n                    writer.println(product);\n                }\n            }\n        }\n    }\n\n    interface Input extends Closeable {\n        String next() throws IOException;\n\n        default int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        default long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n\n    private static class StandardInput implements Input {\n        private final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        private StringTokenizer stringTokenizer;\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public String next() throws IOException {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n                stringTokenizer = new StringTokenizer(reader.readLine());\n            }\n            return stringTokenizer.nextToken();\n        }\n    }\n}'),(33,5,'Java',_binary 'import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class CF1114F {\n	class STADD { // lol my segment tree was wrong before\n		int n, h;  long t[], d[];\n		public STADD(int nn) {\n			t = new long[(n = nn) << 1];\n			d = new long[n];\n			h = 32 - Integer.numberOfLeadingZeros(n);\n		}\n		void apply(int p, long v, int k) {\n			t[p] = (t[p] + (v * k)) % (MOD - 1);\n			if(p < n) d[p] = (d[p] + v) % (MOD - 1);\n		}\n		void build(int p) {\n			for(int k = 2 ; p > 1 ; k <<= 1) {\n				p = (p >> 1);\n				t[p] = (t[p << 1] + t[p << 1 | 1] + (d[p] * k)) % (MOD - 1);\n			}\n		}\n		void push(int p) {\n			for(int s = h, k = (1 << (h - 1)) ; s > 0 ; s--, k >>= 1) {\n				int i = (p >> s);\n				if(d[i] != 0) {\n					apply(i << 1, d[i], k);\n					apply(i << 1 | 1, d[i], k);\n					d[i] = 0;\n				}\n			}\n		}\n		void inc(int l, int r, long v) { // increments [l, r] by v\n			l += n;  r += n + 1;\n			int l0 = l, r0 = r, k = 1;\n			for(; l < r ; l >>= 1, r >>= 1, k <<= 1) {\n				if((l & 1) > 0) apply(l++, v, k);\n				if((r & 1) > 0) apply(--r, v, k);\n			}\n			build(l0);  build(r0 - 1);\n		}\n		long query(int l, int r) { // finds sum on [l, r]\n			l += n;  r += n + 1;\n			push(l);  push(r - 1);\n			long res = 0; // adding longs but it didn\'t say it was wrong\n			for(; l < r ; l >>= 1, r >>= 1) {\n				if((l & 1) > 0) res += t[l++];\n				if((r & 1) > 0) res += t[--r];\n				res %= (MOD - 1);\n			}\n			return res;\n		}\n	}\n	class STOR {\n		int n, h;  long t[], d[];\n		public STOR(int nn) {\n			t = new long[(n = nn) << 1];\n			d = new long[n];\n			h = 32 - Integer.numberOfLeadingZeros(n);\n		}\n		void apply(int p, long v) { t[p] |= v;  if(p < n) d[p] |= v; }\n		void build(int p) { while(p > 1) { p >>= 1;  t[p] = (t[p << 1] | t[p << 1 | 1]) | d[p]; } }\n		void push(int p) {\n			for(int s = h ; s > 0 ; s--) {\n				int i = (p >> s);\n				if(d[i] != 0) {\n					apply(i << 1, d[i]);\n					apply(i << 1 | 1, d[i]);\n					d[i] = 0;\n				}\n			}\n		}\n		void or(int l, int r, long v) { // increments [l, r] by v\n			l += n;  r += n + 1;\n			int l0 = l, r0 = r;\n			for(; l < r ; l >>= 1, r >>= 1) {\n				if((l & 1) > 0) apply(l++, v);\n				if((r & 1) > 0) apply(--r, v);\n			}\n			build(l0);  build(r0 - 1);\n		}\n		long query(int l, int r) { // finds min on [l, r]\n			l += n;  r += n + 1;\n			push(l);  push(r - 1);\n			long res = 0;\n			for(; l < r ; l >>= 1, r >>= 1) {\n				if((l & 1) > 0) res |= t[l++];\n				if((r & 1) > 0) res |= t[--r];\n			}\n			return res;\n		}\n	}\n	long inv(long x, int MOD) { return exp(x, MOD - 2, MOD); }\n	long exp(long b, long e, long m) {\n		if(e == 0) return 1;\n		long res = exp(b, e / 2, m);\n		res = (res * res) % m;\n		if((e & 1) > 0) res = (res * b) % m;\n		return res;\n	}\n	long dlog(long g, long b, long p) {\n		long gm = exp(g, -m + 2 * (p - 1), p);\n		for(int i = 0 ; i < m ; i++) {\n			if(powers.containsKey(b)) return i * m + powers.get(b);\n			b = b * gm % p;\n		}\n		return -1;\n	}\n	Map<Long, Long> powers;\n	final int MOD = (int) 1e9 + 7;\n	final int g = 5; // primitive root of 1e9 + 7\n	final long m = (long) (Math.ceil(Math.sqrt(MOD - 1)) + 0.5);\n	public CF1114F() {\n		System.err.println(\"Go!\");\n		powers = new HashMap<>();\n		for(long j = 0 ; j < m ; j++) powers.put(exp(g, j, MOD), j);\n		long[] dlog = new long[301];\n		for(int i = 2 ; i < 301 ; i++)\n			dlog[i] = dlog(g, i, MOD);\n		long[] mask = new long[301];\n		long[] invs = new long[100];\n		int bit = 0;\n		boolean[] isPrime = new boolean[301];\n		Arrays.fill(isPrime, true);\n		isPrime[0] = isPrime[1] = false;\n		for(int i = 2 ; i < 301 ; i++) {\n			if(isPrime[i]) {\n				mask[i] = (1L << bit);\n				for(int j = i + i ; j < 301 ; j += i) {\n					mask[j] |= (1L << bit);\n					isPrime[j] = false;\n				}\n				invs[bit] = (inv(i, MOD) * (i - 1)) % MOD;\n				bit++;\n			}\n		}\n		//		STOR st = new STOR(5);\n		//		st.or(0, 0, 0b1/* kenobi*/);\n		//		st.or(2, 3, 0b10100);\n		//		st.or()\n		//		for(int i = 0 ; i < 5 ; i++)\n		//			System.out.print(Long.toBinaryString(st.query(i, i)) + \" \");\n		//		if(true) return;\n		FS scan = new FS();\n		PrintWriter out = new PrintWriter(System.out);\n		int n = scan.nextInt(), q = scan.nextInt();\n		STADD sta = new STADD(n);\n		STOR sto = new STOR(n);\n		for(int i = 0 ; i < n ; i++) {\n			int x = scan.nextInt();\n			sta.inc(i, i, dlog[x]);\n			sto.or(i, i, mask[x]);\n		}\n		for(int qq = 0 ; qq < q ; qq++) {\n			if(scan.next().charAt(0) == \'M\') {\n				int L = scan.nextInt() - 1, R = scan.nextInt() - 1, x = scan.nextInt();\n				sta.inc(L, R, dlog[x]);\n				sto.or(L, R, mask[x]);\n			} else {\n				int L = scan.nextInt() - 1, R = scan.nextInt() - 1;\n				long primes = sto.query(L, R);\n				long pow = sta.query(L, R);\n				long res = exp(g, pow, MOD);\n				while(primes > 0) {\n					bit = Long.numberOfTrailingZeros(primes & -primes);\n					res = (res * invs[bit]) % MOD;\n					primes -= primes & -primes;\n				}\n				out.println(res);\n			}\n		}\n		out.close();\n	}\n	class FS {\n		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n		StringTokenizer st = new StringTokenizer(\"\");\n		public String next() {\n			while(!st.hasMoreTokens()) {\n				try { st = new StringTokenizer(br.readLine()); }\n				catch(Exception e) { e.printStackTrace(); }\n			}\n			return st.nextToken();\n		}\n		public int nextInt() { return Integer.parseInt(next()); }\n	}\n	public static void main(String[] args) { new CF1114F(); }\n}\n/*\n64 5\n64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64\nMULTIPLY 12 46 2\nMULTIPLY 11 32 7\nMULTIPLY 14 23 3\nMULTIPLY 6 39 3\nTOTIENT 12 16\n384868693\n384868693\n */'),(34,5,'Java',_binary 'import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileNotFoundException;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Asgar Javadov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static int[] prime = NumberTheory.primes(300);\n        long[] powers = new long[prime.length];\n        int[] oneMinusInversePrime = new int[prime.length];\n        TaskF.LazyPropagationProduct treeProduct;\n        TaskF.LazyPropagationOr treeOr;\n        int n;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int q = in.nextInt();\n            int[] a = in.readIntArray(n);\n            this.n = n;\n\n            init();\n\n            treeProduct = new TaskF.LazyPropagationProduct(a);\n            treeOr = new TaskF.LazyPropagationOr(a);\n\n            while (q-- > 0) {\n                String type = in.next();\n                int l = in.nextInt() - 1;\n                int r = in.nextInt() - 1;\n\n                if (\"MULTIPLY\".equals(type)) {\n                    int x = in.nextInt();\n                    treeProduct.update(l, r, x);\n                    treeOr.update(l, r, TaskF.LazyPropagationOr.getPrimeBitMask(x));\n                } else {\n                    int result = treeProduct.get(l, r);\n                    long orResult = treeOr.get(l, r);\n\n                    for (int i = 0; i < prime.length; i++) {\n                        if ((orResult & powers[i]) == 0L) continue;\n                        result = NumberTheory.multiply(result, oneMinusInversePrime[i]);\n                    }\n                    out.println(result);\n                }\n            }\n        }\n\n        private void init() {\n            for (int i = 0; i < prime.length; i++) {\n                int inverse = NumberTheory.inverse(prime[i]);\n                oneMinusInversePrime[i] = NumberTheory.subtract(1, inverse);\n            }\n\n            for (int i = 0; i < prime.length; i++) {\n                powers[i] = 1L << i;\n            }\n        }\n\n        static class LazyPropagationOr {\n            int n;\n            long[] tree;\n            long[] lazy;\n\n            LazyPropagationOr(int length) {\n                this.n = length - 1;\n\n                int sz = Integer.highestOneBit(length) << 2;\n                tree = new long[sz];\n                lazy = new long[sz];\n            }\n\n            LazyPropagationOr(int[] arr) {\n                this(arr.length);\n\n                build(1, 0, this.n, arr);\n            }\n\n            private void build(int node, int l, int r, int[] arr) {\n                if (l >= r) {\n                    tree[node] = getPrimeBitMask(arr[l]);\n                    return;\n                }\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                build(leftSon, l, mid, arr);\n                build(rightSon, mid + 1, r, arr);\n\n                this.tree[node] = tree[leftSon] | tree[rightSon];\n            }\n\n            public static long getPrimeBitMask(int value) {\n                long result = 0L;\n                for (int i = 0; i < prime.length; i++) {\n                    if (value % prime[i] == 0)\n                        result |= 1L << i;\n                }\n                return result;\n            }\n\n            public long get(int qs, int qe) {\n                return get(1, 0, n, qs, qe);\n            }\n\n            private long get(int node, int l, int r, int qs, int qe) {\n                if (lazy[node] != 0L) {\n                    propagate(node, l, r);\n                }\n\n                if (qe < l || r < qs || l > r)\n                    return 0L;\n\n                if (qs <= l && r <= qe)\n                    return tree[node];\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                return get(leftSon, l, mid, qs, qe) | get(rightSon, mid + 1, r, qs, qe);\n            }\n\n            public void update(int qs, int qe, long value) {\n                update(1, 0, n, qs, qe, value);\n            }\n\n            private void update(int node, int l, int r, int qs, int qe, long value) {\n                if (lazy[node] != 0L) {\n                    propagate(node, l, r);\n                }\n\n                if (qe < l || r < qs || l > r)\n                    return;\n\n                if (qs <= l && r <= qe) {\n                    lazy[node] |= value;\n                    propagate(node, l, r);\n                    return;\n                }\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                update(leftSon, l, mid, qs, qe, value);\n                update(rightSon, mid + 1, r, qs, qe, value);\n\n                tree[node] = tree[leftSon] | tree[rightSon];\n            }\n\n            private void propagate(int node, int l, int r) {\n                tree[node] |= lazy[node];\n\n                if (l != r) {\n                    int leftSon = node << 1;\n                    int rightSon = leftSon | 1;\n                    lazy[leftSon] |= lazy[node];\n                    lazy[rightSon] |= lazy[node];\n                }\n\n                lazy[node] = 0L;\n            }\n\n        }\n\n        static class LazyPropagationProduct {\n            int n;\n            int[] tree;\n            int[] lazy;\n\n            public LazyPropagationProduct(int length) {\n                this.n = length - 1;\n\n                int sz = Integer.highestOneBit(length) << 2;\n                tree = new int[sz];\n                lazy = new int[sz];\n            }\n\n            public LazyPropagationProduct(int[] a) {\n                this(a.length);\n\n                build(1, 0, this.n, a);\n            }\n\n            protected void build(int node, int l, int r, int[] arr) {\n                if (l >= r) {\n                    this.tree[node] = arr[l];\n                    this.lazy[node] = 1;\n                    return;\n                }\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                build(leftSon, l, mid, arr);\n                build(rightSon, mid + 1, r, arr);\n\n                this.tree[node] = NumberTheory.multiply(tree[leftSon], tree[rightSon]);\n                this.lazy[node] = 1;\n            }\n\n            public int get(int qs, int qe) {\n                return get(1, 0, n, qs, qe);\n            }\n\n            protected int get(int node, int l, int r, int qs, int qe) {\n                if (lazy[node] != 1)\n                    propagate(node, l, r);\n\n                if (qe < l || r < qs || l > r)\n                    return 1;\n\n                if (qs <= l && r <= qe)\n                    return tree[node];\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                return NumberTheory.multiply(get(leftSon, l, mid, qs, qe), get(rightSon, mid + 1, r, qs, qe));\n            }\n\n            public void update(int qs, int qe, int value) {\n                update(1, 0, n, qs, qe, value);\n            }\n\n            protected void update(int node, int l, int r, int qs, int qe, int value) {\n                if (lazy[node] != 1)\n                    propagate(node, l, r);\n\n                if (qe < l || r < qs || r < l)\n                    return;\n\n                if (qs <= l && r <= qe) {\n                    lazy[node] = NumberTheory.multiply(lazy[node], value);\n                    propagate(node, l, r);\n                    return;\n                }\n\n                int mid = l + r >> 1;\n                int leftSon = node << 1;\n                int rightSon = leftSon | 1;\n\n                update(leftSon, l, mid, qs, qe, value);\n                update(rightSon, mid + 1, r, qs, qe, value);\n\n                tree[node] = NumberTheory.multiply(tree[leftSon], tree[rightSon]);\n            }\n\n            protected void propagate(int node, int l, int r) {\n                tree[node] = NumberTheory.multiply(tree[node], NumberTheory.powmod(lazy[node], (r - l + 1)));\n                if (l != r) {\n                    int leftSon = node << 1;\n                    int rightSon = leftSon | 1;\n                    lazy[leftSon] = NumberTheory.multiply(lazy[leftSon], lazy[node]);\n                    lazy[rightSon] = NumberTheory.multiply(lazy[rightSon], lazy[node]);\n                }\n\n                lazy[node] = 1;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter extends PrintWriter {\n        public OutputWriter(OutputStream outputStream) {\n            super(outputStream);\n        }\n\n        public OutputWriter(Writer writer) {\n            super(writer);\n        }\n\n        public OutputWriter(String filename) throws FileNotFoundException {\n            super(filename);\n        }\n\n        public void close() {\n            super.close();\n        }\n\n    }\n\n    static class NumberTheory {\n        public static int MODULO = 1_000_000_007;\n\n        public static int multiply(int a, int b) {\n            long product = a * (long) b;\n            if (product >= MODULO)\n                product %= MODULO;\n            return (int) product;\n        }\n\n        public static int subtract(int a, int b) {\n            return subtract(a, b, MODULO);\n        }\n\n        public static int subtract(int a, int b, int modulo) {\n            if (a >= b)\n                return a - b;\n            else\n                return a - b + modulo;\n        }\n\n        public static int powmod(int a, long n) {\n            return powmod(a, n, MODULO);\n        }\n\n        public static int powmod(int a, long n, int mod) {\n            long res = 1L;\n            long half = a;\n            while (n != 0) {\n                if ((n & 1) == 1)\n                    res = res * half % mod;\n                half = half * half % mod;\n                n >>= 1;\n            }\n            return (int) res;\n        }\n\n        public static int inverse(int a) {\n            return powmod(a, MODULO - 2, MODULO);\n        }\n\n        public static int[] primes(final int nInclusive) {\n            boolean[] prime = new boolean[nInclusive + 1];\n            Arrays.fill(prime, 2, prime.length, true);\n\n            for (int i = 2; i * i <= nInclusive; ++i)\n                if (prime[i]) {\n                    for (int j = i * i; j <= nInclusive; j += i) {\n                        prime[j] = false;\n                    }\n                }\n\n            int numOfPrimes = 0;\n            for (int i = 2; i <= nInclusive; ++i)\n                if (prime[i])\n                    ++numOfPrimes;\n\n            int[] result = new int[numOfPrimes];\n            for (int j = 0, i = 2; i <= nInclusive; ++i)\n                if (prime[i])\n                    result[j++] = i;\n\n            return result;\n        }\n\n    }\n\n    static class InputReader extends BufferedReader {\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream inputStream) {\n            super(new InputStreamReader(inputStream), 32768);\n        }\n\n        public InputReader(String filename) {\n            super(new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(filename)));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public Integer nextInt() {\n            return Integer.valueOf(next());\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++)\n                array[i] = nextInt();\n            return array;\n        }\n\n    }\n}\n '),(35,1,'C++',_binary '// Dmitry _kun_ Sayutin (2019)\n \n#include <bits/stdc++.h>\n \nusing std::cin;\nusing std::cout;\nusing std::cerr;\n \nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n \nusing std::pair;\nusing std::make_pair;\n \nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n \nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n \nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n \n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n \ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n \ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n \n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n \nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n \n    // code here\n    int x = input<int>();\n    int y = input<int>();\n    int z = input<int>();\n    int green = input<int>();\n    int purple = input<int>();\n    int black = input<int>();\n \n    if (x <= green and x + y <= green + purple and x + y + z <= green + purple + black)\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    \n    return 0;\n}\n'),(36,2,'C++',_binary '// Dmitry _kun_ Sayutin (2019)\n \n#include <bits/stdc++.h>\n \nusing std::cin;\nusing std::cout;\nusing std::cerr;\n \nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n \nusing std::pair;\nusing std::make_pair;\n \nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n \nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n \nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n \n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n \ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n \ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n \n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n \nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n \n    // code here\n    int n = input<int>();\n    int m = input<int>();\n    int k = input<int>();\n \n    vector<int> a(n);\n    input_seq(ALL(a));\n \n    vector<int> ind(n);\n    std::iota(ALL(ind), 0);\n \n    std::sort(ALL(ind), [&](int i, int j) {return a[i] > a[j];});\n \n    ind.resize(k * m);\n \n    sort(ALL(ind));\n \n    int64_t ans = 0;\n    for (int i: ind)\n        ans += a[i];\n \n    cout << ans << \"\\n\";\n \n    for (int i = 0; i < k - 1; ++i)\n        cout << ind[m - 1 + m * i] + 1 << \" \";\n    cout << \"\\n\";\n    \n    return 0;\n}'),(37,4,'C++',_binary '// Dmitry _kun_ Sayutin (2019)\n \n#include <bits/stdc++.h>\n \nusing std::cin;\nusing std::cout;\nusing std::cerr;\n \nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n \nusing std::pair;\nusing std::make_pair;\n \nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n \nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n \nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n \n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n \ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n \ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n \n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n \nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n \n    // code here\n    \n    int n = input<int>();\n \n    int lo = 0; // true\n    int hi = (int)1e9 + 1; // not true\n \n    while (hi - lo > 1) {\n        int mi = lo + (hi - lo) / 2;\n \n        cout << \"> \" << mi << std::endl;\n \n        if (input<int>() == 1)\n            lo = mi;\n        else\n            hi = mi;\n    }\n \n    int largest = lo + 1;\n \n    std::mt19937 rnd((size_t)(new char()));\n \n    std::uniform_int_distribution<int> dist(1, n);\n \n    set<int> ask;\n    while (SZ(ask) < 30 and SZ(ask) < n)\n        ask.insert(dist(rnd));\n \n    int step = 0;\n    \n    for (int elem: ask) {\n        cout << \"? \" << elem << std::endl;\n        \n        step = std::__gcd(step, largest - input<int>());\n    }\n \n    cout << \"! \" << largest - (n - 1) * step << \" \" << step << \"\\n\";\n    \n    return 0;\n}\n');
/*!40000 ALTER TABLE `solutions` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-11-18 19:58:25
